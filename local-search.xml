<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++的lambda表达式</title>
    <link href="/lambda_in_cpp/"/>
    <url>/lambda_in_cpp/</url>
    
    <content type="html"><![CDATA[<p>在 C++ 中，<strong>lambda 表达式</strong>（或匿名函数）是一种简洁的方式来定义函数对象或小型的临时函数。它引入于 <strong>C++11</strong>，并在 <strong>C++14</strong> 和 <strong>C++17</strong> 中得到了进一步扩展。Lambda 表达式的主要特点是能够在函数中内联定义临时逻辑，而无需显式声明一个函数。</p><h3 id="基本语法"><strong>基本语法</strong></h3><p>C++ 的 lambda 表达式的一般形式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[capture](parameters) -&gt; return_type &#123; body &#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>[capture]</code></strong>：捕获列表，用于指定 lambda 如何访问其外部作用域中的变量。</li><li><strong><code>(parameters)</code></strong>：参数列表，类似普通函数的参数列表。</li><li><strong><code>-&gt; return_type</code></strong>（可选）：返回值类型。如果可以自动推断返回类型，则可以省略。</li><li><strong><code>&#123; body &#125;</code></strong>：函数体，包含要执行的逻辑。</li></ul><hr><h3 id="简单示例"><strong>简单示例</strong></h3><p>以下是一个简单的 lambda 表达式示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 lambda 表达式打印每个数字</span><br>    std::for_each(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> num) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><hr><h3 id="捕获列表（-capture-）"><strong>捕获列表（<code>[capture]</code>）</strong></h3><p>捕获列表定义了 lambda 如何访问外部变量。常见的捕获方式包括：</p><ol><li><p><strong>按值捕获</strong>（<code>[x]</code>）：<br>将外部变量的值拷贝到 lambda 中。lambda 内的修改不会影响外部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> f = [x]() &#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;;<br><span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 输出 10</span><br>x = <span class="hljs-number">20</span>;   <span class="hljs-comment">// 修改外部的 x</span><br><span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 仍然输出 10（lambda 内的 x 是拷贝）</span><br></code></pre></td></tr></table></figure></li><li><p><strong>按引用捕获</strong>（<code>[&amp;x]</code>）：<br>lambda 捕获的是变量的引用，lambda 内对变量的修改会影响外部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> f = [&amp;x]() &#123; x += <span class="hljs-number">5</span>; &#125;;<br><span class="hljs-built_in">f</span>();  <span class="hljs-comment">// 修改了外部的 x</span><br>std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 输出 15</span><br></code></pre></td></tr></table></figure></li><li><p><strong>捕获全部变量</strong>：</p><ul><li><code>[=]</code>：按值捕获所有外部变量。</li><li><code>[&amp;]</code>：按引用捕获所有外部变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> lambda1 = [=]() &#123; <span class="hljs-keyword">return</span> a + b; &#125;;  <span class="hljs-comment">// 按值捕获</span><br><span class="hljs-keyword">auto</span> lambda2 = [&amp;]() &#123; b += a; &#125;;       <span class="hljs-comment">// 按引用捕获</span><br></code></pre></td></tr></table></figure></li><li><p><strong>混合捕获</strong>：<br>捕获特定变量，同时按值或引用捕获其他变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> lambda = [a, &amp;b]() &#123; b += a; &#125;; <span class="hljs-comment">// a 按值捕获，b 按引用捕获</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="返回值"><strong>返回值</strong></h3><p>C++11 中，lambda 的返回值通常是自动推断的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; y)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> y;<br>&#125;; <span class="hljs-comment">// 返回值自动推断为 int</span><br></code></pre></td></tr></table></figure><p>如果返回值类型不一致，编译器则会报错。</p><p>如果返回类型复杂或需要显式指定，可以使用 <code>-&gt; return_type</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">double</span> &#123;<br>    <span class="hljs-keyword">return</span> x / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(y);<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="Lambda-表达式的实际用途"><strong>Lambda 表达式的实际用途</strong></h3><ol><li><p><strong>排序</strong><br>使用 lambda 定义自定义的排序逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a &gt; b; <span class="hljs-comment">// 按降序排序</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>过滤</strong><br>使用 lambda 筛选元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>nums.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove_if</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123;<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// 移除所有偶数</span><br>&#125;), nums.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure></li><li><p><strong>异步操作</strong><br>使用 lambda 编写回调函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from lambda in a thread!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="注意事项"><strong>注意事项</strong></h3><ol><li><p><strong>捕获列表的生命周期</strong>：<br>捕获的变量按值或按引用会影响它的生命周期：</p><ul><li>按值捕获是拷贝，原变量的修改不会影响捕获的值。</li><li>按引用捕获需要确保变量在 lambda 的生命周期内仍然有效。</li></ul></li><li><p><strong>可变 lambda</strong>：<br>默认情况下，当lambda使用按值捕获(<code>[x]</code>)时，是不可修改捕获的值的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> lambda = [x]() &#123; x += <span class="hljs-number">5</span>; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;; <span class="hljs-comment">// 这里会报错：表达式必须是可修改的左值</span><br><br></code></pre></td></tr></table></figure><p>如果需要修改捕获的值，可以用 <code>mutable</code> 关键字，<code>mutable</code> 允许修改捕获的副本（注意，是副本，不是原来的<code>x</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> lambda = [x]() <span class="hljs-keyword">mutable</span> &#123; x += <span class="hljs-number">5</span>; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;;<br><span class="hljs-built_in">lambda</span>(); <span class="hljs-comment">// 输出 15</span><br>std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 原来的 x 仍然是 10</span><br></code></pre></td></tr></table></figure></li><li><p><strong>嵌套 lambda</strong>：<br>Lambda 表达式可以嵌套使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> outer = [](<span class="hljs-type">int</span> x) &#123;<br>    <span class="hljs-keyword">return</span> [x](<span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> inner = <span class="hljs-built_in">outer</span>(<span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-built_in">inner</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出 15</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="总结">总结</h3><p>Lambda 表达式使得 C++ 更加灵活，尤其是在需要传递临时函数或函数对象的场景中（例如排序、回调等）。使用它可以大大减少代码的冗余，提高代码的可读性和可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL查询每组中最大值的前N条记录</title>
    <link href="/MySQL_group_top_n/"/>
    <url>/MySQL_group_top_n/</url>
    
    <content type="html"><![CDATA[<p>在数据查询中，经常会遇到按特定字段分组并在每组中选取前 N 条记录的需求。假设我们有一个学生成绩表 <code>score</code> ，包含字段 <code>subject</code>（学科）、 <code>name</code>（学生名字）和<code>score</code>（分数），我们的任务是查询每个学科的前三名。</p><p>本文将讲解如何在 MySQL 8.0 及以上版本中使用窗口函数实现这一需求，并探讨如何在 MySQL 8.0 以下版本中达成同样的效果。</p><hr><h2 id="场景描述">场景描述</h2><p>假设 <code>score</code> 表的数据结构如下：</p><table><thead><tr><th>subject</th><th>name</th><th>score</th></tr></thead><tbody><tr><td>语文</td><td>张三</td><td>89</td></tr><tr><td>语文</td><td>李四</td><td>90</td></tr><tr><td>语文</td><td>王五</td><td>77</td></tr><tr><td>语文</td><td>赵六</td><td>85</td></tr><tr><td>语文</td><td>钱七</td><td>69</td></tr><tr><td>数学</td><td>张三</td><td>59</td></tr><tr><td>数学</td><td>李四</td><td>98</td></tr><tr><td>数学</td><td>王五</td><td>77</td></tr><tr><td>数学</td><td>赵六</td><td>65</td></tr><tr><td>数学</td><td>钱七</td><td>39</td></tr></tbody></table><p>在此数据结构下，每条记录表示某个学生某一科目的成绩。我们希望查询每个学科中 <code>score</code> 最大的前三条记录。</p><hr><h2 id="MySQL-8-0-及以上版本：使用窗口函数-ROW-NUMBER">MySQL 8.0 及以上版本：使用窗口函数 <code>ROW_NUMBER()</code></h2><p>在 MySQL 8.0 及以上版本，可以使用窗口函数 <code>ROW_NUMBER()</code> 为每组数据分配行号，从而筛选出每组中的前 N 条记录。</p><h3 id="查询语句">查询语句</h3><p>以下 SQL 语句可以获取每个 <code>subject</code> 中 <code>score</code> 最大的前三条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> <br>        <span class="hljs-operator">*</span>,<br>        <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> `subject` <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> row_num<br>    <span class="hljs-keyword">FROM</span> <br>        score<br>) <span class="hljs-keyword">AS</span> ranked<br><span class="hljs-keyword">WHERE</span> <br>    row_num <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="查询逻辑解析">查询逻辑解析</h3><ol><li><p><strong><code>ROW_NUMBER()</code></strong>：为每条记录分配行号。</p><ul><li><code>PARTITION BY subject</code> 按 <code>subject</code> 将数据划分成多个分组。</li><li><code>ORDER BY score DESC</code> 使得每组中的 <code>score</code> 值从大到小排列。</li></ul></li><li><p><strong>外层查询过滤结果</strong>：</p><ul><li><code>WHERE row_num &lt;= 3</code> 保留每组中行号小于等于 3 的记录，得到每个学科 <code>score</code> 最大的前三条记录。</li></ul></li></ol><h3 id="查询结果示例">查询结果示例</h3><p>在上面的示例数据下，查询结果如下：</p><table><thead><tr><th>subect</th><th>name</th><th>score</th><th>row_num</th></tr></thead><tbody><tr><td>数学</td><td>李四</td><td>98</td><td>1</td></tr><tr><td>数学</td><td>王五</td><td>77</td><td>2</td></tr><tr><td>数学</td><td>赵六</td><td>65</td><td>3</td></tr><tr><td>语文</td><td>李四</td><td>90</td><td>1</td></tr><tr><td>语文</td><td>张三</td><td>89</td><td>2</td></tr><tr><td>语文</td><td>赵六</td><td>85</td><td>3</td></tr></tbody></table><hr><h2 id="MySQL-8-0-以下版本：使用子查询和-JOIN-实现">MySQL 8.0 以下版本：使用子查询和 <code>JOIN</code> 实现</h2><p>在 MySQL 5.7 及以下版本中，窗口函数不可用。我们可以通过定义变量的方式来模拟同样的效果。我们使用两个变量：<code>@sub</code>和<code>@rank</code>来表示当前的学科和排行：</p><h3 id="查询语句-2">查询语句</h3><p>假设我们想查询每个 <code>subject</code> 中 <code>score</code> 最大的前三条记录，可以按以下步骤完成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `subject`, `name`, `score`<br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span><br>        score.<span class="hljs-operator">*</span>,<br>         <span class="hljs-variable">@rank</span> :<span class="hljs-operator">=</span> IF(<span class="hljs-variable">@sub</span> <span class="hljs-operator">=</span> `subject`, <span class="hljs-variable">@rank</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> `rank`,<br>         <span class="hljs-variable">@sub</span> :<span class="hljs-operator">=</span> `subject`<br>    <span class="hljs-keyword">FROM</span> score<br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `subject`, score <span class="hljs-keyword">DESC</span><br>) <span class="hljs-keyword">AS</span> ranked<br><span class="hljs-keyword">WHERE</span> `rank` <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="查询逻辑解析-2">查询逻辑解析</h3><ol><li>使用 <code>@sub</code> 记录当前组的名称。</li><li>使用 <code>@rank</code> 对每个组的记录进行排名：<ul><li>如果当前记录与上一次记录属于同一组，则排名递增。</li><li>如果是新组，则排名从 1 开始。</li></ul></li><li>在外部查询中过滤出排名在 3以内的记录。</li></ol><h3 id="查询结果">查询结果</h3><p>这将返回与使用窗口函数的查询相同的结果，但性能在数据量较大时可能不如窗口函数方法。</p><hr><h2 id="总结">总结</h2><p>本文介绍了如何在 MySQL 中按分组查询每组中最大值的前 N 条记录。在 MySQL 8.0 及以上版本，可以借助 <code>ROW_NUMBER()</code> 窗口函数实现高效查询；在 MySQL 8.0 以下版本中，使用子查询和记录变量也能达到相同效果。</p><hr><h2 id="参考资料">参考资料</h2><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions.html">MySQL 8.0 窗口函数 - 官方文档</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/subqueries.html">MySQL 5.7 子查询 - 官方文档</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html">MySQL 排序和分组查询 - 官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP模拟多继承的方式：traits</title>
    <link href="/php_traits/"/>
    <url>/php_traits/</url>
    
    <content type="html"><![CDATA[<p>在面向对象编程中，<strong>继承</strong>是一个很常用的概念，允许类从其他类继承属性和方法。然而，<strong>多继承</strong>（即一个类可以同时继承多个父类）一直是开发者讨论的话题。一些编程语言，包括 PHP，<strong>不支持多继承</strong>，但 PHP 提供了一种独特的方式来解决这个问题——<code>traits</code>。接下来我们探讨一下 PHP 为什么不支持多继承，以及如何通过 <code>traits</code> 达到类似多继承的效果。</p><h3 id="什么是继承？为什么多继承有问题？">什么是继承？为什么多继承有问题？</h3><p><strong>继承</strong>是指一个类可以从另一个类继承其属性和方法。在 PHP 中，这种继承关系是单一的，也就是说，一个子类只能继承一个父类。</p><h4 id="单继承示例：">单继承示例：</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eat</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Eating...\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bark</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Barking...\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-variable">$dog</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-variable">$dog</span>-&gt;<span class="hljs-title function_ invoke__">eat</span>();  <span class="hljs-comment">// 输出：Eating...</span><br><span class="hljs-variable">$dog</span>-&gt;<span class="hljs-title function_ invoke__">bark</span>(); <span class="hljs-comment">// 输出：Barking...</span><br></code></pre></td></tr></table></figure><p>上面的例子展示了典型的单继承，<code>Dog</code> 类继承了 <code>Animal</code> 类的 <code>eat()</code> 方法，同时定义了自己的 <code>bark()</code> 方法。</p><h3 id="为什么-PHP-不支持多继承？">为什么 PHP 不支持多继承？</h3><p>在多继承的场景中，问题通常出现在<strong>方法冲突</strong>上。假设你从两个不同的父类继承了两个同名的方法，编译器或解释器如何知道该使用哪一个？这种冲突被称为<strong>菱形继承问题</strong>，会导致代码的可维护性下降。</p><p><strong>多继承的复杂性</strong>可以通过下面的伪代码来说明：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Action from A&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Action from B&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>, <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-comment">// 问题：C 继承了两个类都有 action()，应该调用哪个？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为 PHP 设计时考虑到了这种复杂性，它只允许<strong>单继承</strong>。但 PHP 开发者仍然需要一种灵活的机制来复用代码。为了解决这个问题，PHP 5.4 引入了 <strong><code>traits</code></strong>，允许开发者在多个类之间共享代码片段，而不必通过传统的继承。</p><h3 id="什么是-traits？如何帮助实现类似多继承的效果？">什么是 <code>traits</code>？如何帮助实现类似多继承的效果？</h3><p><code>traits</code> 是一种机制，允许你将可复用的方法或属性集打包到一个独立的单元中，并将它们应用到不同的类中。与继承不同，<code>traits</code> 不是类，而是代码片段的集合，多个类可以使用同一个或多个 <code>trait</code>，从而实现代码共享。</p><h4 id="使用-traits-实现多继承的效果">使用 <code>traits</code> 实现多继承的效果</h4><p>让我们来看一个使用 <code>traits</code> 的例子，展示如何将多个特性组合到一个类中，进而模拟多继承的效果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 定义第一个 trait</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Logger</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"><span class="hljs-variable">$message</span></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Logging message: <span class="hljs-subst">$message</span>\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义第二个 trait</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Notifier</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notify</span>(<span class="hljs-params"><span class="hljs-variable">$message</span></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Sending notification: <span class="hljs-subst">$message</span>\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 traits 的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">use</span> <span class="hljs-title">Logger</span>, <span class="hljs-title">Notifier</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createUser</span>(<span class="hljs-params"><span class="hljs-variable">$name</span></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;User <span class="hljs-subst">$name</span> created.\n&quot;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&quot;User <span class="hljs-subst">$name</span> has been created.&quot;</span>);<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">notify</span>(<span class="hljs-string">&quot;User <span class="hljs-subst">$name</span> has been created.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化 User 类并使用方法</span><br><span class="hljs-variable">$user</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-variable">$user</span>-&gt;<span class="hljs-title function_ invoke__">createUser</span>(<span class="hljs-string">&quot;zhang san&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="运行结果：">运行结果：</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">User</span> <span class="hljs-title">zhang</span> san created.<br>Logging message: <span class="hljs-keyword">User</span> <span class="hljs-title">zhang</span> san has been created.<br>Sending notification: <span class="hljs-keyword">User</span> <span class="hljs-title">zhang</span> san has been created.<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个 <code>trait</code>：<code>Logger</code> 和 <code>Notifier</code>，分别提供了 <code>log()</code> 和 <code>notify()</code> 方法。<code>User</code> 类使用了这两个 <code>trait</code>，从而获得了这两个方法的功能。这样，我们成功地模拟了“多继承”的效果。</p><h3 id="traits-的优势"><code>traits</code> 的优势</h3><ol><li><strong>代码复用</strong>：<code>traits</code> 提供了一种将可复用代码分离出来，并在多个类中复用的方式。这减少了代码冗余，并提高了维护性。</li><li><strong>避免继承冲突</strong>：在继承的世界里，多继承带来了复杂的父类冲突问题。使用 <code>traits</code>，可以通过明确地控制哪一个 <code>trait</code> 提供的方法被使用，避免这些冲突。</li><li><strong>组合特性</strong>：通过 <code>traits</code>，你可以灵活地组合多个不同功能的代码到一个类中，而不需要通过传统的继承体系来完成这些功能的组合。</li></ol><h3 id="当多个-traits-有冲突时：优雅的解决方案">当多个 <code>traits</code> 有冲突时：优雅的解决方案</h3><p><code>traits</code> 中可能会出现方法冲突的情况。PHP 提供了一个机制来解决这些冲突，你可以通过<strong>方法别名</strong>和<strong>方法覆盖</strong>来明确调用哪个 <code>trait</code> 的方法。</p><h4 id="示例：">示例：</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Logger</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Logging from Logger trait.\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">FileLogger</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Logging from FileLogger trait.\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-keyword">use</span> <span class="hljs-title">Logger</span>, <span class="hljs-title">FileLogger</span> &#123;<br>        <span class="hljs-title">Logger</span>::<span class="hljs-title">log</span> <span class="hljs-title">insteadof</span> <span class="hljs-title">FileLogger</span>;  <span class="hljs-comment">// 使用 Logger 中的 log 方法</span><br>        <span class="hljs-title class_">FileLogger</span>::<span class="hljs-variable constant_">log</span> <span class="hljs-keyword">as</span> fileLog;        <span class="hljs-comment">// 给 FileLogger 中的 log 方法取别名</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">log</span>();      <span class="hljs-comment">// 调用 Logger 的 log 方法</span><br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">fileLog</span>();  <span class="hljs-comment">// 调用 FileLogger 的 log 方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-variable">$app</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();<br><span class="hljs-variable">$app</span>-&gt;<span class="hljs-title function_ invoke__">run</span>();<br></code></pre></td></tr></table></figure><h4 id="输出结果：">输出结果：</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Logging <span class="hljs-keyword">from</span> Logger <span class="hljs-keyword">trait</span>.<br>Logging <span class="hljs-keyword">from</span> FileLogger <span class="hljs-keyword">trait</span>.<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Logger</code> 和 <code>FileLogger</code> 都定义了 <code>log()</code> 方法。通过 <code>insteadof</code> 关键字，我们明确告诉 PHP 使用哪个 <code>trait</code> 的方法。同时，我们给另一个 <code>trait</code> 的方法起了别名，以便在需要时调用它。</p><h3 id="属性">属性</h3><p><code>traits</code> 同样可以定义属性。</p><h4 id="示例">示例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>  <br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PropertiesTrait</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$x</span> = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertiesExample</span> </span>&#123;<br>    <span class="hljs-keyword">use</span> <span class="hljs-title">PropertiesTrait</span>;<br>&#125;<br><br><span class="hljs-variable">$example</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesExample</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$example</span>-&gt;x;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-variable">$example</span>-&gt;x++;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$example</span>-&gt;x;<br></code></pre></td></tr></table></figure><h4 id="输出结果">输出结果</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br></code></pre></td></tr></table></figure><p><code>traits</code> 定义了一个属性后，如果类中要定义同样名称的属性，必须是同样的访问可见度、类型、readonly 修饰符和初始默认值，否则会产生 fatal error。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PropertiesTrait</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$same</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$different1</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-variable">$different2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-variable">$different3</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertiesExample</span> </span>&#123;<br>    <span class="hljs-keyword">use</span> <span class="hljs-title">PropertiesTrait</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$same</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$different1</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Fatal error：初始默认值不同</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$different2</span>; <span class="hljs-comment">// Fatal error：类型不同</span><br>    <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">bool</span> <span class="hljs-variable">$different3</span>; <span class="hljs-comment">// Fatal error：修饰符不同</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="traits-的局限性"><code>traits</code> 的局限性</h3><p>尽管 <code>traits</code> 是 PHP 中非常强大的工具，但它们并不是类。<code>traits</code> 无法实例化，也不能用于创建对象。因此，如果你的场景需要复杂的继承结构，<code>traits</code> 可能并不是最佳的选择。此外，过度使用 <code>traits</code> 可能导致代码的可读性下降，尤其是在项目中引入了大量不同的 <code>trait</code> 时。</p><h3 id="总结">总结</h3><p>虽然 PHP 不支持多继承，但通过 <code>traits</code>，开发者可以轻松地复用代码，并实现类似多继承的效果。<code>traits</code> 提供了一种灵活且强大的机制，使代码更加模块化，同时避免了多继承带来的复杂性和潜在问题。</p><p>在日常开发中，合理使用 <code>traits</code> 能够提高代码的可读性和复用性，使你能够优雅地应对不同类之间共享功能的需求。</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.php.net/manual/zh/language.oop5.traits.php">PHP 手册 - Trait</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>skynet的cluster集群</title>
    <link href="/skynet_cluster/"/>
    <url>/skynet_cluster/</url>
    
    <content type="html"><![CDATA[<h2 id="集群的使用">集群的使用</h2><p>现在的游戏服务器框架中，分布式是一种常见的需求。一个游戏服务器组通常可以分成<strong>网关服务器、登录服务器、逻辑服务器、跨服服务器</strong>等等。<br>在<code>skynet</code>中，我们可以通过<code>cluster</code>来组建一个集群，实现分布式的部署。</p><h3 id="示例">示例</h3><p>我们先来看一个简单的例子，在这里我们实现了两个<code>skynet</code>结点(进程)：一个称为<code>center</code>，一个称为<code>game</code>。<br>在<code>center</code>中启动一个<code>data</code>服务，然后<code>game</code>结点向<code>center</code>结点的<code>data</code>服务获取数据。<br><img src="/files/img/cluster_node.png" alt="img"><br><code>center</code>结点有两个文件<code>centerMain</code>和<code>dataService</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--centerMain.lua</span><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;skynet&quot;</span>)<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;skynet.manager&quot;</span>)<br><span class="hljs-keyword">local</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;skynet.cluster&quot;</span>)<br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>   <span class="hljs-comment">--打开结点：表示当前进程是center结点，监听center端口</span><br>   cluster.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;center&quot;</span>)<br><br>   <span class="hljs-comment">--启动dataService服务</span><br>   <span class="hljs-keyword">local</span> addr = skynet.newservice(<span class="hljs-string">&quot;dataService&quot;</span>)<br><br>   <span class="hljs-comment">--注册名字，以便其他结点访问</span><br>   skynet.name(<span class="hljs-string">&quot;.dataService&quot;</span>, addr)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--dataService.lua</span><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> kv = &#123;&#125;<br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>   skynet.dispatch(<span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(session, source, cmd, k, v)</span></span><br>      <span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&quot;set&quot;</span> <span class="hljs-keyword">then</span><br>         kv[k] = v<br>      <span class="hljs-keyword">elseif</span> cmd == <span class="hljs-string">&quot;get&quot;</span> <span class="hljs-keyword">then</span><br>         skynet.retpack(kv[k])<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p><code>game</code>结点连接<code>center</code>结点，访问<code>dataService</code>服务：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;skynet&quot;</span>)<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;skynet.manager&quot;</span>)<br><span class="hljs-keyword">local</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;skynet.cluster&quot;</span>)<br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>   <span class="hljs-comment">--使用cluster.send/call</span><br>   cluster.send(<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-string">&quot;.data&quot;</span>, <span class="hljs-string">&quot;set&quot;</span>, <span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>)<br>   <span class="hljs-built_in">print</span>(cluster.call(<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-string">&quot;.data&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;k1&quot;</span>))<br><br>   <span class="hljs-comment">--使用skynet.send/call</span><br>   <span class="hljs-keyword">local</span> addr = cluster.proxy(<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-string">&quot;.data&quot;</span>)<br>   skynet.send(addr, <span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;set&quot;</span>, <span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>)<br>   <span class="hljs-built_in">print</span>(skynet.call(addr, <span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;k1&quot;</span>))<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>在配置文件中，我们需要指定一个<code>cluster</code>文件：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">--config<br><span class="hljs-attribute">cluster</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;./config/clusterConfig.lua&quot;</span><br><br>--config/clusterConfig.lua<br>__nowaiting <span class="hljs-operator">=</span> true <br><span class="hljs-attribute">center</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;127.0.0.1:14880&quot;</span><br><span class="hljs-attribute">game</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;127.0.0.1:14881&quot;</span><br></code></pre></td></tr></table></figure><p>这样一个简单的<code>skynet</code>集群就搭建好了</p><h3 id="cluster库"><code>cluster</code>库</h3><p>在示例中，我们看到集群的监听和发送，都是通过<code>cluster</code>这个库来操作的。<code>cluster</code>是一个封装的用来进行集群相关操作的函数库，通过<code>local cluster = require(&quot;skynet.cluster&quot;)</code>引入<br>主要的函数有：</p><h4 id="1-cluster-reload">1. cluster.reload</h4><p><code>cluster.reload</code>用来加载配置。除了通过配置文件之外，我们也可以使用<code>cluster.reload</code>来加载配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">cluster.reload(&#123;<br>   center=<span class="hljs-string">&quot;127.0.0.1:14880&quot;</span>,<br>   game=<span class="hljs-string">&quot;127.0.0.1:14881&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果不传参数的话，则表示重新从配置文件中加载：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">cluster.reload()<br></code></pre></td></tr></table></figure><blockquote><p><code>reload</code>是新加配置，对于旧的结点，如果没有被覆盖到则没有影响。想要清除旧的结点，可以配置<code>node=nil</code></p></blockquote><blockquote><p>可以通过配置节点名字对应的地址为 false 来明确指出这个节点已经下线</p></blockquote><h4 id="2-cluster-open">2. cluster.open</h4><p><code>cluster.open</code>表示监听指定的端口。示例中，在<code>center</code>结点，我们使用<code>cluster.open('center')</code>来监听<code>center</code>端口，在这里是监听<code>127.0.0.1:14880</code>。</p><p>这里会发一条<code>listen</code>指令给到<code>clusterd</code>，<code>clusterd</code>启动<code>gate</code>服务，并通过<code>gate</code>服务来监听端口。</p><blockquote><p><code>clusterd</code>在收到<code>listen</code>时，会启动一个<code>gate</code>服务，所以如果你有自定义的网关服务，最好不要用<code>gate</code>这个服务名。</p></blockquote><p>在一个进程里，我们可以<code>open</code>多个端口，如果其他结点不会主动连接本结点，那也可以不<code>open</code>任何端口。</p><h4 id="3-cluster-send-cluster-call">3. cluster.send / cluster.call</h4><p><code>send</code>和<code>call</code>可以向指定的结点发送<code>lua</code>消息。<br>其效果和在目标结点上，发送<code>lua</code>消息一样。<br>在<code>game</code>结点上执行：<br><code>cluster.send(&quot;center&quot;, &quot;.dataService&quot;, &quot;set&quot;, &quot;k1&quot;, &quot;v1&quot;)</code><br>相当于在<code>center</code>结点上执行：<br><code>skynet.send(&quot;.dataService&quot;, &quot;lua&quot;, &quot;set&quot;, &quot;k1&quot;, &quot;v1&quot;)</code></p><h4 id="4-cluster-proxy">4. cluster.proxy</h4><p><code>cluster.proxy</code>用于生成一个代理地址，使发送跨结点的消息看起来和发送本地消息一样:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> addr = cluster.proxy(<span class="hljs-string">&#x27;center&#x27;</span>, <span class="hljs-string">&#x27;.dataService&#x27;</span>)<br>skynet.send(addr, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;k1&#x27;</span>, <span class="hljs-string">&#x27;v1&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>和发送本地消息的区别在于，这种方式下，skynet.send只能支持lua消息。</p></blockquote><h4 id="5-cluster-register-cluster-query">5. cluster.register / cluster.query</h4><p><code>cluster.register</code>用于给某个服务在当前结点注册个名字。<br>其他结点，则可以使用<code>cluster.query</code>来判断目标结点是否存在某个服务。</p><h3 id="clusterd服务"><code>clusterd</code>服务</h3><p>当我们引入<code>cluster</code>库时，会启动一个唯一服务<code>clusterd</code>，这是在<code>cluster.lua</code>文件中，通过<code>skynet.init</code>的方式启动的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--cluster.lua</span><br>skynet.init(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    clusterd = skynet.uniqueservice(<span class="hljs-string">&quot;clusterd&quot;</span>)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p><code>cluster</code>库的函数，基本上都是通过发送<code>lua</code>消息到<code>clusterd</code>服务来进行的。<br><img src="/files/img/cluster_clusterd.png" alt="img"><br><code>clusterd</code>会处理以下<code>lua</code>消息：</p><h4 id="1-reload">1. reload</h4><p><code>clusterd</code>维护一个<code>node_address</code>表，用来记录每个结点对应的IP地址和端口。</p><h4 id="2-listen">2. listen</h4><p>收到<code>listen</code>消息时，<code>clusterd</code>会启动一个<code>gate</code>服务。然后根据结点名，获取结点地址，启动<code>gate</code>监听网络端口。<br>当这个<code>gate</code>服务收到网络连接时，会发送<code>lua</code>消息<code>socket</code>到<code>clusterd</code>服务，然后由<code>clusterd</code>启动一个<code>clusteragent</code>服务，来处理这个连接的消息：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command.socket</span><span class="hljs-params">(source, subcmd, fd, msg)</span></span><br><span class="hljs-keyword">if</span> subcmd == <span class="hljs-string">&quot;open&quot;</span> <span class="hljs-keyword">then</span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;socket accept from %s&quot;</span>, msg))<br><span class="hljs-comment">-- new cluster agent</span><br>cluster_agent[fd] = <span class="hljs-literal">false</span><br><span class="hljs-keyword">local</span> agent = skynet.newservice(<span class="hljs-string">&quot;clusteragent&quot;</span>, skynet.<span class="hljs-built_in">self</span>(), source, fd)<br><span class="hljs-comment">--...其他代码</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">--...关闭和错误处理</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="3-register">3. register</h4><p><code>clusterd</code>维护一个<code>register_name</code>表，用来记录注册的服务名和地址。</p><h4 id="4-proxy">4. proxy</h4><p><code>clusterd</code>维护一个<code>proxy</code>表，记录<code>结点名.服务名</code>对应的代理地址，当代理地址不存在时，则创建一个<code>clusterproxy</code>服务。</p><h4 id="5-sender">5. sender</h4><p><code>clusterd</code>维护一个<code>node_channel</code>表，记录结点对应的<code>clustersender</code>地址，这里会返回结点对应的<code>clustersender</code>地址，没有则先创建一个。</p><h3 id="发送消息到其他结点">发送消息到其他结点</h3><ul><li><code>cluster.send</code><br><code>cluster.send</code>会通过一个<code>clustersender</code>服务来发送消息。先看看代码：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cluster.send</span><span class="hljs-params">(node, address, ...)</span></span><br><span class="hljs-comment">-- push is the same with req, but no response</span><br><span class="hljs-keyword">local</span> s = sender[node]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">then</span><br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(task_queue[node], skynet.packstring(address, ...))<br><span class="hljs-keyword">else</span><br>skynet.send(sender[node], <span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, address, skynet.pack(...))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在<code>cluster</code>中维护着<code>sender</code>列表，在同一个服务里，<code>sender</code>记录每个<code>node</code>对应的<code>clustersender</code>服务。<br>当<code>sender[node]</code>不存在的时候，没有直接创建一个<code>clustersender</code>，而是将当前的参数打包，然后插入到一个<code>task_queue</code>队列中，这是因为创建服务是一个阻塞的过程，在创建服务的过程中，可能会再次调用<code>cluster.send</code>，所以这里将所有创建过程中的参数都缓存起来，等<code>clustersender</code>创建完成后，再统一发送到目标结点。<br>而创建<code>clustersender</code>，又是发送消息到<code>clusterd</code>服务：<code>local ok, c = pcall(skynet.call, clusterd, &quot;lua&quot;, &quot;sender&quot;, node)</code></p><blockquote><p><code>skynet.packstring</code>可以将多个参数(字符串，数字，表，布尔值)序列化成一个字符串。可以使用<code>skynet.unpack</code>反序列化将参数解出。</p></blockquote><ul><li><code>cluster.call</code><br><code>cluster.call</code>同样是通过<code>clustersender</code>服务来发送消息。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cluster.call</span><span class="hljs-params">(node, address, ...)</span></span><br><span class="hljs-comment">-- skynet.pack(...) will free by cluster.core.packrequest</span><br><span class="hljs-keyword">local</span> s = sender[node]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> task = skynet.packstring(address, ...)<br><span class="hljs-keyword">return</span> skynet.call(get_sender(node), <span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;req&quot;</span>, repack(skynet.<span class="hljs-built_in">unpack</span>(task)))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> skynet.call(s, <span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;req&quot;</span>, address, skynet.pack(...))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>cluster.send</code>使用<code>task_queue</code>可以立刻返回，不会阻塞，而<code>cluster.call</code>本身就是会阻塞的，所以可以直接使用<code>get_sender</code>，以阻塞的形式获取一个<code>clustersender</code>。</p><p>注意这里先将参数序列化，等获取到<code>sender</code>之后才重新化序列化，这是因为<code>get_sender</code>这个过程是阻塞的，而参数有可能是个<code>table</code>，在阻塞的过程中，这个<code>table</code>中的值有可能发生变化，导致逻辑不符合预期，所以这里通过序列化来保证发送时的参数不会被改变。</p><h3 id="clustersender服务"><code>clustersender</code>服务</h3><p><code>clustersender</code>用来连接指定结点并发送数据。这个服务是在第一次发送数据时才创建的。<br>在集群中，结点A向结点B发送过消息，那么结点A就有一个指向结点B的<code>clustersender</code>服务，<strong>且只有一个</strong>。</p><blockquote><p><code>clustersender</code>服务是在<code>clusterd</code>服务中创建的，<code>clusterd</code>是一个唯一服务，在这个服务的管理下，每个目标结点只有一个<code>clustersender</code>服务。</p></blockquote><p>现在我们来看看<code>clustersender</code>服务是怎么发送数据的。</p><p>启动服务时，我们传过来四个参数<br><code>node</code>: 连接的集群的结点名字<br><code>nodename</code>: 主机的hostname<br><code>init_host</code>: <code>socket</code>连接的地址<br><code>init_port</code>: <code>socket</code>连接的端口</p><p>在<code>skynet.start</code>时，创建了一个<code>skynet.socketchannel</code>，然后设置<code>lua</code>消息处理函数，这里主要处理两种服务：</p><ul><li><code>push</code><br><code>push</code>对应的是<code>cluster.send</code>，只负责发送，不需要响应。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command.push</span><span class="hljs-params">(addr, msg, sz)</span></span><br><span class="hljs-keyword">local</span> request, new_session, padding = cluster.packpush(addr, session, msg, sz)<br><span class="hljs-keyword">if</span> padding <span class="hljs-keyword">then</span><span class="hljs-comment">-- is multi push</span><br>session = new_session<br><span class="hljs-keyword">end</span><br><br>channel:request(request, <span class="hljs-literal">nil</span>, padding)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里的<code>cluster</code>的<code>C</code>层的库，不是<code>lua</code>层的库。<br><code>cluster.packpush</code>按特定的协议，来打包数据。<br><code>cluster.packpush</code>返回三个值：<br><code>request</code>：打包后的二进制数据。<br><code>new_session</code>：<code>session+1</code>。<br><code>padding</code>：如果数据过大，则将超过单包上限的二进制数据以<code>table</code>数组的形式放在<code>padding</code>里。</p><p><code>channel:request</code>则是将<code>request</code>发送给对端主机，如果有<code>padding</code>，则分多个包发出去。这里第二个参数是<code>response</code>，这里为<code>nil</code>表示不需要响应。</p><ul><li><code>req</code><br><code>req</code>对应的是<code>cluster.call</code>，需要等待响应的返回。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send_request</span><span class="hljs-params">(addr, msg, sz)</span></span><br><span class="hljs-comment">-- msg is a local pointer, cluster.packrequest will free it</span><br><span class="hljs-keyword">local</span> current_session = session<br><span class="hljs-keyword">local</span> request, new_session, padding = cluster.packrequest(addr, session, msg, sz)<br>session = new_session<br><br><span class="hljs-keyword">local</span> tracetag = skynet.tracetag()<br><span class="hljs-keyword">if</span> tracetag <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> tracetag:<span class="hljs-built_in">sub</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) ~= <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-keyword">then</span><br><span class="hljs-comment">-- add nodename</span><br><span class="hljs-keyword">local</span> newtag = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;(%s-%s-%d)%s&quot;</span>, nodename, node, session, tracetag)<br>skynet.tracelog(tracetag, <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;session %s&quot;</span>, newtag))<br>tracetag = newtag<br><span class="hljs-keyword">end</span><br>skynet.tracelog(tracetag, <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;cluster %s&quot;</span>, node))<br>channel:request(cluster.packtrace(tracetag))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> channel:request(request, current_session, padding)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command.req</span><span class="hljs-params">(...)</span></span><br><span class="hljs-keyword">local</span> ok, msg = <span class="hljs-built_in">pcall</span>(send_request, ...)<br><span class="hljs-keyword">if</span> ok <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(msg) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">then</span><br>skynet.ret(cluster.<span class="hljs-built_in">concat</span>(msg))<br><span class="hljs-keyword">else</span><br>skynet.ret(msg)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>skynet.<span class="hljs-built_in">error</span>(msg)<br>skynet.response()(<span class="hljs-literal">false</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>command.req</code>调用<code>send_request</code>，返回值如果是<code>table</code>表示这是一个大包切割成多个小包，需要使用<code>cluster.concat</code>连接起来再返回，如果是<code>string</code>则直接返回。<br>在<code>send_request</code>中，<code>cluster.packrequest</code>和<code>cluster.packpush</code>类似，来打包<code>request</code>类型的数据。<br>最后同样是交给<code>channel:request</code>来发送<code>socket</code>消息，和<code>push</code>不同的是，这里第二个参数传入了<code>current_session</code>，表示接收响应的会话ID。</p><p>这里简单的讲一下<code>channel:request</code>是怎么发送和接收数据的。<br><code>channel:request</code>首先会检查当前的连接状态：</p><ul><li>如果<code>socket</code>连接还没建立，则先建立连接，再发送数据；</li><li>如果<code>socket</code>连接已断开，则会抛出异常；</li><li>如果<code>socket</code>连接正常，则直接发送数据。<br>在发送数据的时候，如果数据包太大(超过<code>32K</code>)，则会切分成多个包来发送。</li></ul><p>如果需要等待响应数据，那么会调用<code>socketchannel</code>的<code>__response</code>函数，这个函数是在<code>socketchannel</code>初始化的时候传入的，在<code>socketsender</code>这里，则是<code>read_response</code>函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_response</span><span class="hljs-params">(sock)</span></span><br><span class="hljs-keyword">local</span> sz = socket.header(sock:<span class="hljs-built_in">read</span>(<span class="hljs-number">2</span>))<br><span class="hljs-keyword">local</span> msg = sock:<span class="hljs-built_in">read</span>(sz)<br><span class="hljs-keyword">return</span> cluster.unpackresponse(msg)<span class="hljs-comment">-- session, ok, data, padding</span><br><span class="hljs-keyword">end</span><br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>channel = sc.channel &#123;<br>host = init_host,<br>port = <span class="hljs-built_in">tonumber</span>(init_port),<br>response = read_response,<br>nodelay = <span class="hljs-literal">true</span>,<br>&#125;<br>skynet.dispatch(<span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(session , source, cmd, ...)</span></span><br><span class="hljs-keyword">local</span> f = <span class="hljs-built_in">assert</span>(command[cmd])<br>f(...)<br><span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p><code>read_response</code>中，<code>sock:read</code>是一个阻塞函数，接收对端<code>socket</code>传回来的网络消息。</p><h3 id="clsteragent服务"><code>clsteragent</code>服务</h3><p>前面提到过，当<code>clustersender</code>第一次发送数据时，会先建立<code>socket</code>连接，而当<code>socket</code>连接建立时，对面的结点会创建一个<code>clusteragent</code>服务，来处理收到的数据。<br><code>clusteragent</code>的创建是在<code>clusterd</code>服务中：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command.socket</span><span class="hljs-params">(source, subcmd, fd, msg)</span></span><br><span class="hljs-keyword">if</span> subcmd == <span class="hljs-string">&quot;open&quot;</span> <span class="hljs-keyword">then</span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;socket accept from %s&quot;</span>, msg))<br><span class="hljs-comment">-- new cluster agent</span><br>cluster_agent[fd] = <span class="hljs-literal">false</span><br><span class="hljs-keyword">local</span> agent = skynet.newservice(<span class="hljs-string">&quot;clusteragent&quot;</span>, skynet.<span class="hljs-built_in">self</span>(), source, fd)<br>        <span class="hljs-comment">--...其他代码</span><br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">--...其他代码</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>可以看到，创建<code>clusteragent</code>的时候，传入了三个参数：<code>clusterd</code>地址、<code>source</code>地址(即<code>gate</code>地址)、<code>fd</code>文件描述符(代表这个<code>socket</code>)。<br><code>clusteragent</code>在调用<code>skynet.start</code>的时候，设置<code>gate</code>服务的转发，将来自<code>fd</code>的网络消息，都转发到这个<code>clusteragent</code>地址，然后设置了对网络消息的处理：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">skynet.register_protocol &#123;<br>    name = <span class="hljs-string">&quot;client&quot;</span>,<br>    id = skynet.PTYPE_CLIENT,<br>    <span class="hljs-built_in">unpack</span> = cluster.unpackrequest,<br>    dispatch = dispatch_request,<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>cluster.unpackrequest</code>将<code>clustersender</code>传过来的网络数据进行解析，然后分配给<code>dispatch_request</code>处理：<br><code>dispatch_request(_,_,addr, session, msg, sz, padding, is_push)</code><br><code>clustersender</code>中会将服务地址<code>addr</code>打包，这里将<code>addr</code>解析出来，<code>addr</code>可以是字符串，也可以是数字。<br>当<code>addr</code>是数字<code>0</code>的时候，表示查询某个注册名字的数字地址：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--结点A</span><br>cluster.register(<span class="hljs-string">&quot;name&quot;</span>, addr)<br><br><span class="hljs-comment">--结点B</span><br><span class="hljs-keyword">local</span> addr = cluster.call(<span class="hljs-string">&quot;NodeA&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;name&quot;</span>) <span class="hljs-comment">--返回NodeA中注册的&quot;name&quot;的数字地址</span><br></code></pre></td></tr></table></figure><p>当<code>addr</code>是字符串或大于0的数字，则判断<code>addr</code>是不是通过<code>cluster.register</code>注册过的，如果是则<code>addr</code>转化成注册的地址。 然后再根据<code>is_push</code>，来执行<code>skynet.rawcall</code>或<code>skynet.rawsend</code>，进行数据转发。 如果是<code>call</code>，最后还需要将数据通过<code>socket</code>返回给<code>clustersender</code>。</p><h3 id="clusterproxy服务">clusterproxy服务</h3><p>当我们调用<code>cluster.proxy(node, addr)</code>时，会向<code>clusterd</code>申请一个<code>clusterproxy</code>服务。<br>这里的参数，有三种形式：</p><ul><li>cluster.proxy(“center”, “.data”)</li><li>cluster.proxy(“center.addr”) ：等价于 cluster.proxy(“center”, “.data”)</li><li>cluster.proxy(“center@addr”) ：等价于 cluster.proxy(“center”, “@data”)<br><code>clusterd</code>会以<code>node .. &quot;.&quot; .. name</code>作为<code>key</code>，保证同一个<code>key</code>只有一个<code>clusterproxy</code>服务。</li></ul><p>而<code>clusterproxy</code>服务很简单：<br>它会向<code>clusterd</code>申请一个面向<code>node</code>的<code>clustersender</code>，然后就收到的<code>lua</code>消息，转发到这个<code>clustersender</code>上，参数使用服务初始化时的<code>addr</code>。<br><img src="/files/img/cluster_topic.png" alt="img"></p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://github.com/cloudwu/skynet/wiki/Cluster#cluster-mode">github skynet wiki</a></li><li><a href="https://blog.codingnow.com/2017/03/skynet_cluster.html">skynet cluster 模块的设计与编码协议</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>skynet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>skynet热更新之inject</title>
    <link href="/skynet_hotfix_by_inject/"/>
    <url>/skynet_hotfix_by_inject/</url>
    
    <content type="html"><![CDATA[<p>游戏服务器的热更新是一种常见的需求，<code>skynet</code>可以通过<code>inject</code>的方式，来修改一个服务的消息处理函数，达到热更新的效果。</p><h3 id="skynet内置服务debug-console">skynet内置服务debug_console</h3><p><code>skynet</code>自带了一个调试控制台服务。<code>inject</code>注入代码需要先启动这个服务。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">skynet.newservice(<span class="hljs-string">&quot;debug_console&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;9666&quot;</span>)<br></code></pre></td></tr></table></figure><p>启动之后，我们可以用<code>telnet</code>或者<code>nc</code>等指令来登录调试控制台。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt; nc 127.0.0.1 9666<br></code></pre></td></tr></table></figure><p>输入<code>list</code>指令，可以得到当前系统中所有服务的地址：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">list<br>:00000004       snlua cdummy<br>:00000006       snlua datacenterd<br>:00000007       snlua service_mgr<br>:00000008       snlua main<br>:00000009       snlua debug_console 127.0.0.1 9666<br>:0000000a       snlua serviceA<br>&lt;CMD OK&gt;<br></code></pre></td></tr></table></figure><p>输入<code>inject</code>指令，我们可以将某个代码文件，注入到指定的服务中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">inject :0000000a service/hotfix.lua<br><br>&lt;CMD OK&gt;<br></code></pre></td></tr></table></figure><p>更多的debug_console指令可以参考<a href="https://github.com/cloudwu/skynet/wiki/DebugConsole">这里</a></p><h3 id="inject实例">inject实例</h3><p>我们在系统启动时，打开debug_console，然后启动服务<code>serviceA</code>，接着设置每隔5秒给<code>serviceA</code>发送两个lua消息，一个参数<code>bar</code>，一个参数<code>foo</code>，代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--main.lua</span><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    skynet.newservice(<span class="hljs-string">&quot;debug_console&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;9666&quot;</span>)<br>    <span class="hljs-keyword">local</span> addr = skynet.newservice(<span class="hljs-string">&quot;serviceA&quot;</span>)<br>    <br>    <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span><span class="hljs-params">()</span></span><br>        skynet.send(addr, <span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>)<br>        skynet.send(addr, <span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>)<br>        skynet.timeout(<span class="hljs-number">500</span>, tick)<br>    <span class="hljs-keyword">end</span><br><br>    skynet.timeout(<span class="hljs-number">500</span>, tick)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>在服务<code>serverA</code>中，我们根据参数，调用不同的处理函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--serviceA.lua</span><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> handles = &#123;&#125;<br><br>handles.foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;foo&quot;</span>)<br><span class="hljs-keyword">end</span><br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    skynet.dispatch(<span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(session, source, cmd, ...)</span></span><br>        <span class="hljs-keyword">local</span> handle = handles[cmd]<br>        <span class="hljs-keyword">if</span> handle <span class="hljs-keyword">then</span><br>            handle()<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cmd not found&quot;</span>, cmd)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>现在我们启动<code>skynet</code>，可以看到每隔5秒输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">foo<br>cmd not found   bar<br></code></pre></td></tr></table></figure><p>现在我们新建一个文件<code>hotfix.lua</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--hotfix.lua</span><br><span class="hljs-keyword">local</span> handles = _P.lua.handles<br><span class="hljs-keyword">local</span> <span class="hljs-built_in">print</span> = <span class="hljs-built_in">_G</span>.<span class="hljs-built_in">print</span><br>handles.foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;foo after hotfix&quot;</span>)<br><span class="hljs-keyword">end</span><br><br>handles.bar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bar after hotfix&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>接下来连接到控制台，并输入<code>inject</code>指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;inject :0000000a services/hotfix.lua&#x27;</span> | nc 127.0.0.1 9666<br></code></pre></td></tr></table></figure><p>等到下次输出的时候，我们看到的就是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">foo after hotfix<br>bar after hotfix<br></code></pre></td></tr></table></figure><p>更新完成，修改了<code>foo</code>函数，新增了<code>bar</code>函数。</p><blockquote><p>使用<code>inject</code>调用<code>hotfix.lua</code>时，<code>print</code>函数是被修改过成<code>debug_console</code>的返回输出函数，所以如果要用到print的话，需要使用全局变量_G.print</p></blockquote><h3 id="对upValue的处理">对upValue的处理</h3><p>如果我们的<code>serviceA</code>是这样的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--serviceA.lua</span><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> handles = &#123;&#125;<br><br><span class="hljs-keyword">local</span> N = <span class="hljs-number">1</span><br><span class="hljs-keyword">local</span> T = &#123;<br>    count = <span class="hljs-number">0</span>,<br>&#125;<br><br>handles.foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    N = N + <span class="hljs-number">2</span><br>    T.count = T.count + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;foo&quot;</span>, N, T.count)<br><span class="hljs-keyword">end</span><br><br>handles.bar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    N = N - <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bar&quot;</span>, N)<br><span class="hljs-keyword">end</span><br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    skynet.dispatch(<span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(session, source, cmd, ...)</span></span><br>        <span class="hljs-keyword">local</span> handle = handles[cmd]<br>        <span class="hljs-keyword">if</span> handle <span class="hljs-keyword">then</span><br>            handle()<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cmd not found&quot;</span>, cmd)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p><code>foo</code>函数带有两个upValue: <code>N</code>和<code>T</code>，<code>bar</code>函数带有一个upValue: <code>N</code> 如果<code>hotfix.lua</code>文件没有做特殊处理，直接覆盖函数的话，那么就会丢失这些upValue。那么，要怎么处理这些upValue呢？这里需要用到<code>lua</code>的<code>debug</code>库，主要是两个函数：</p><ul><li><code>debug.getupvalue(f, i)</code>: 获取函数<code>f</code>中的第<code>i</code>个<code>upValue</code>的变量名和值。</li><li><code>debug.upvaluejoin(f1, i, f2, j)</code>：让函数<code>f1</code>的第<code>i</code>个<code>upValue</code>引用<code>f2</code>中的第<code>j</code>个<code>upValue</code>。</li></ul><p>热更新带有upValue的函数，我们的<code>hotfix.lua</code>分三步走：</p><ol><li>定义一个函数<code>get_up</code>，来获取原有的函数的<code>upValue</code>列表。</li><li>定义新的处理函数。</li><li>定义一个函数<code>uv_join</code>，将新函数的<code>upValue</code>和旧函数的<code>upValue</code>绑定起来。</li></ol><p>完整代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> handles = _P.lua.handles<br><span class="hljs-keyword">local</span> <span class="hljs-built_in">print</span> = <span class="hljs-built_in">_G</span>.<span class="hljs-built_in">print</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_up</span><span class="hljs-params">(f)</span></span><br>    <span class="hljs-keyword">local</span> u = &#123;&#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> f <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> u<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> name = <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getupvalue</span>(f, i)<br>        <span class="hljs-keyword">if</span> name == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> u<br>        <span class="hljs-keyword">end</span><br>        u[name] = i<br>        i = i + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> u<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uv_join</span><span class="hljs-params">(f, old_f, old_uv)</span></span><br>    <span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> name = <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getupvalue</span>(f, i)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">if</span> old_uv[name] <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">debug</span>.upvaluejoin(f, i, old_f, old_uv[name])<br>        <span class="hljs-keyword">end</span><br>        i = i + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> foo = handles.foo<br><span class="hljs-keyword">local</span> up = get_up(foo)<br><br><span class="hljs-keyword">local</span> N, T      <span class="hljs-comment">--定义两个upValue，否则函数里会变成全局变量</span><br>handles.foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    N = N + <span class="hljs-number">200</span><br>    T.count = T.count + <span class="hljs-number">100</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;foo&quot;</span>, N, T.count)<br><span class="hljs-keyword">end</span><br>uv_join(handles.foo, foo, up)<br></code></pre></td></tr></table></figure><blockquote><p>这里的<code>get_up</code>函数只取了传入函数的upValue，如果要嵌套处理函数中的函数，可以参考<code>lualib/skynet/inject.lua</code>中的<code>getupvaluetable</code>函数。</p></blockquote><h3 id="inject实现原理">inject实现原理</h3><p><code>debug_console</code>服务的代码位于<code>service/debug_console.lua</code>文件中，其对<code>inject</code>指令的处理，其实就是发送一条<code>debug</code>类型的消息到目标服务：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--debug_console.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">COMMAND.inject</span><span class="hljs-params">(address, filename, ...)</span></span><br>address = adjust_address(address)<br><span class="hljs-keyword">local</span> f = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;rb&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> f <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Can&#x27;t open &quot;</span> .. filename<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> source = f:<span class="hljs-built_in">read</span> <span class="hljs-string">&quot;*a&quot;</span><br>f:<span class="hljs-built_in">close</span>()<br><span class="hljs-keyword">local</span> ok, <span class="hljs-built_in">output</span> = skynet.call(address, <span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-string">&quot;RUN&quot;</span>, source, filename, ...)<br><span class="hljs-keyword">if</span> ok == <span class="hljs-literal">false</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">error</span>(<span class="hljs-built_in">output</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">output</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在我们的服务中，当我们<code>require 'skynet'</code>的时候，会自动注册<code>debug</code>消息类型的处理：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--lualib/skynet.lua</span><br><span class="hljs-comment">-- Inject internal debug framework</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">debug</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet.debug&quot;</span><br><span class="hljs-built_in">debug</span>.init(skynet, &#123;<br>dispatch = skynet.dispatch_message,<br>suspend = suspend,<br><span class="hljs-built_in">resume</span> = coroutine_resume,<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--lualib/skynet/debug.lua</span><br>    skynet.register_protocol &#123;<br>name = <span class="hljs-string">&quot;debug&quot;</span>,<br>id = <span class="hljs-built_in">assert</span>(skynet.PTYPE_DEBUG),<br>pack = <span class="hljs-built_in">assert</span>(skynet.pack),<br><span class="hljs-built_in">unpack</span> = <span class="hljs-built_in">assert</span>(skynet.<span class="hljs-built_in">unpack</span>),<br>dispatch = _debug_dispatch,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，参数<code>RUN</code>是这样处理的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--lualib/skynet/debug.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbgcmd.RUN</span><span class="hljs-params">(source, filename, ...)</span></span><br>    <span class="hljs-keyword">local</span> inject = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet.inject&quot;</span><br>    <span class="hljs-keyword">local</span> args = <span class="hljs-built_in">table</span>.pack(...)<br>    <span class="hljs-keyword">local</span> ok, <span class="hljs-built_in">output</span> = inject(skynet, source, filename, args, export.dispatch, skynet.register_protocol)<br>    <span class="hljs-built_in">collectgarbage</span> <span class="hljs-string">&quot;collect&quot;</span><br>    skynet.ret(skynet.pack(ok, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(<span class="hljs-built_in">output</span>, <span class="hljs-string">&quot;\n&quot;</span>)))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>追溯代码，来到最终的<code>inject</code>函数：<br><img src="/img/blog/skynet_inject.png" alt="image"></p><ol><li>修改<code>print</code>函数，可以返回输出内容给<code>debug_console</code>服务。</li><li>在上一层调用的时候，传进来的<code>...</code>实际上两个函数<code>skynet.dispatch_message</code>和<code>skynet.register_protocol</code>，这里将这两个函数，以及函数中包含的子函数，所用到的<code>upVluae</code>都收集起来，存入表<code>u</code>中。</li><li><code>proto</code>是<code>skynet.register_protocol</code>中用到的一个upValue，存放着当前服务所注册的消息类型。遍历<code>proto</code>，将每个消息的处理函数用到的<code>upValue</code>收集起来，存放到表<code>p</code>中。</li><li>设置环境，调用传入的热更新文件。现在我们知道，在上面的例子中的<code>hotfix.lua</code>，用到的<code>_P</code>，就是存放各种消息类型的处理函数的upValue表。</li></ol><blockquote><p>在控制台调用inject指令时，还可以传入额外的参数，例如：<code>inject :0000000a services/hotfix.lua xxx yyy</code>，最终这两个参数，就是这里的<code>inject</code>函数中的第四个参数<code>args</code>，可以在<code>hotfix.lua</code>中直接使用这两参数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>skynet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏服务器</tag>
      
      <tag>skynet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>skynet的消息发送：send和call</title>
    <link href="/skynet_call_and_send/"/>
    <url>/skynet_call_and_send/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/cloudwu/skynet/wiki">skynet</a>是一个轻量级的游戏服务器框架。</p></blockquote><p>skynet的核心是<strong>服务</strong>，服务之间通过<strong>消息</strong>来通信，消息的来源主要有：</p><ul><li>定时器</li><li>网络</li><li>服务之间的调用(<code>skynet.send</code>或<code>skynet.call</code>)</li></ul><h3 id="skynet-send和skynet-call">skynet.send和skynet.call</h3><p>假设我们有两个服务A和B，A发了两条消息给B：<br><img src="/img/blog/skynet_send_call.png" alt="img"></p><p>这里<code>skynet.send</code>和<code>skynet.call</code>的主要区别，在于<code>call</code>会阻塞，等待消息的返回值，而<code>send</code>将消息发送出去之后，就继续执行后续的指令。那么这里<code>skynet.call</code>之后，是怎么获取这个返回值的呢？我们来看看代码。</p><p>skynet.send的代码比较简单：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skynet.send</span><span class="hljs-params">(addr, typename, ...)</span></span><br><span class="hljs-keyword">local</span> p = proto[typename]<br><span class="hljs-keyword">return</span> c.send(addr, p.id, <span class="hljs-number">0</span>, p.pack(...))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>根据类型，将数据打包，然后调用底层的<code>c.send</code>将消息发送给目标地址。</p><p>再来看看<code>skynet.call</code>的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skynet.call</span><span class="hljs-params">(addr, typename, ...)</span></span><br><span class="hljs-comment">--调试相关代码</span><br><span class="hljs-comment">--...</span><br><br><span class="hljs-keyword">local</span> p = proto[typename]<br><span class="hljs-keyword">local</span> session = c.send(addr, p.id , <span class="hljs-literal">nil</span> , p.pack(...))<br><span class="hljs-keyword">if</span> session == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;call to invalid address &quot;</span> .. skynet.address(addr))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> p.<span class="hljs-built_in">unpack</span>(yield_call(addr, session))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里我们看到，<code>skynet.call</code>和<code>skynet.send</code>在发送数据时，调用的底层函数是一样的，都是c.send，区别在于参数不同：</p><ul><li>skynet.send调用c.send时，第三个参数是0，表示不用分配会话(session)</li><li>skynet.call调用c.send时，第三个参数是nil，表示需要分配会话ID(session)</li></ul><p>这里的session，是系统一个自增的ID，每次分配时增加1，相当于给这一次的call分配一个唯一ID。</p><p>最后，<code>skynet.call</code>的返回是<code>p.unpack(yield_call(addr, session))</code><br><code>p.unpack</code>是解包数据，而<code>yield_call</code>，看名字就知道，是一个挂起的调用：<br><span id="yield_call"></span></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yield_call</span><span class="hljs-params">(service, session)</span></span><br>watching_session[session] = service<br>session_id_coroutine[session] = running_thread<br><span class="hljs-keyword">local</span> succ, msg, sz = coroutine_yield <span class="hljs-string">&quot;SUSPEND&quot;</span> <br>watching_session[session] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> succ <span class="hljs-keyword">then</span><br><span class="hljs-built_in">error</span> <span class="hljs-string">&quot;call failed&quot;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> msg,sz<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里，用到了刚刚分配的<code>session</code>，记录了<code>session</code>对应的<strong>服务地址</strong>和<strong>执行协程</strong>，然后，调用<code>coroutine_yield</code>将线程挂起，参数是&quot;SUSPEND&quot;，等到目标服务返回结果后，才重新回到这个协程。</p><h3 id="处理消息并返回">处理消息并返回</h3><p><strong>服务A</strong>调用<code>skynet.call</code>发送消息给<strong>服务B</strong>之后，A的协程挂起了，收到消息的<strong>服务B</strong>，是怎么处理这个消息，并返回给<strong>服务A</strong>的呢？<br>在<code>skynet</code>的体系中，每个服务都有一个<strong>消息处理函数</strong>。对于skynet的lua服务，在启动时，<code>skynet.start</code>的第一行代码，就是设置<code>lua</code>层面的回调函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skynet.start</span><span class="hljs-params">(start_func)</span></span><br>c.callback(skynet.dispatch_message)<br><span class="hljs-comment">--...其他代码</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>而<code>skynet.dispatch_message</code>中的第一句，则是以pcall的方式调用<code>raw_dispatch_message</code>，这个函数一共有5个参数：</p><ul><li>ptototype: 消息类型</li><li>msg:  消息体</li><li>sz：消息长度</li><li>session：会话ID，使用send的话，则是0</li><li>source：消息来源的服务地址</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">raw_dispatch_message</span><span class="hljs-params">(prototype, msg, sz, session, source)</span></span><br><span class="hljs-comment">-- skynet.PTYPE_RESPONSE = 1, read skynet.h</span><br><span class="hljs-keyword">if</span> prototype == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br><span class="hljs-comment">--...处理响应消息</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">local</span> p = proto[prototype]<br><span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><span class="hljs-comment">--...错误处理</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> f = p.dispatch<br><span class="hljs-keyword">if</span> f <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> co = co_create(f)                 <span class="hljs-comment">-- 取得一个协程</span><br>session_coroutine_id[co] = session      <span class="hljs-comment">-- 并关联协程和会话</span><br>session_coroutine_address[co] = source  <span class="hljs-comment">-- 以及来源</span><br><br>            <span class="hljs-comment">--... trace调试相关代码</span><br>          <br>suspend(co, coroutine_resume(co, session,source, p.<span class="hljs-built_in">unpack</span>(msg,sz)))<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">--...错误处理</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>关键看这一句：<code>suspend(co, coroutine_resume(co, session,source, p.unpack(msg,sz)))</code><br>从里向外，有三个函数调用：</p><ul><li>p.unpack(msg, sz)：根据消息类型预设好的unpack函数，来解析消息，返回解析后的参数。</li><li>coroutine_resume(co, session, source, …)：执行协程，协程参数为session,source,以及解析后的参数。这里实际上就是执行到<code>skynet.dispatch</code>中设置的消息处理函数(上面示例代码中，<code>serverB</code>的函数<code>f</code>)。</li><li>suspend(co, …)：处理完一条消息，挂起后的一些处理。</li></ul><h3 id="skynet-call的返回">skynet.call的返回</h3><p>从上面的消息处理来看，并没有对<code>skynet.call</code>做特别的处理，实际上，对于<code>skynet.call</code>的消息，我们必须手动调用<code>skynet.retpack</code>来返回数据。<br>通常，在消息处理函数中，我们可以通过session，来判断要不要使用skynet.retpack:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> session &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>    skynet.retpack(func(...))<br><span class="hljs-keyword">else</span><br>    func(...)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>skynet.retpack实际上是对skynet.ret的调用：</p><p><img src="/img/blog/skynet_ret.png" alt="img"></p><ol><li>前面收到消息时，记录了当前协程对应的session，这里取出session。</li><li>如果session等于0，表示是<code>send</code>的消息，不需要返回。</li><li>前面收到消息时，还记录当前协程对应的消息来源，这里，给来源地址<code>source</code>发送一个<code>PTYPE_RESPONSE</code>类型的消息，成功将数据返回。</li></ol><p>上面这些返回的操作，是在<strong>服务B</strong>中，而在<strong>服务A</strong>中，就收到了一个<code>PTYPE_RESPONSE</code>消息。此时前面发送<code>skynet.call</code>时的协程<code>co</code>还处于挂起的状态。</p><p>前面讲到<code>raw_dispatch_message</code>的时候，略过了<code>PTYPE_RESPONSE</code>的处理，现在再来看一下：</p><p><img src="/img/blog/skynet_dispatch.png" alt="img"></p><ol><li>通过session取得处理协程，在skynet.call =&gt; yield_call中，挂起之前，记录的session对应哪个协程，这里取回挂起的协程。</li><li><code>RESPONSE</code>并不只是skynet.ret才会用到，还有可能是skynet.timeout的定时时间到了，也会发送<code>RESPONSE</code>，这时co是一个字符串&quot;BREAK&quot;</li><li>收到一个未知的response的处理。</li><li>正常的<code>skynet.call</code>在这里获得返回值，这里的coroutine_resume，执行co协程，就是回到前面的<a href="#yield_call">yield_call</a></li></ol><p><img src="/img/blog/skynet_yield_call_ret.png" alt="img"></p><ol><li>挂起的协程<code>co</code>恢复执行后，接收<code>succ</code>,<code>msg</code>,<code>sz</code>参数，最终<code>yield_call</code>返回的是<code>msg</code>和<code>sz</code>。</li><li>将<code>yield_call</code>的返回值，通过<code>unpack</code>解析之后，最终返回给调用者。至此，<code>skynet.call</code>终于取到了返回值。</li></ol><h3 id="Maybe-forgot-response-session-…-from-…">Maybe forgot response session … from …</h3><p>假设<strong>消息B</strong>在收到一个<code>skynet.call</code>的消息后，没有调用<code>skynet.ret</code>返回，那么会输出一个报错：<code>Maybe forgot response session ... from ...</code>，<code>skynet</code>系统是怎么知道没有返回的呢？<br>前面在讲到消息处理<code>raw_dispatch_message</code>函数中，有一个步骤是从协程池中获取一个协程，并调用设置好的<code>dispatch</code>函数（示例中<code>serviceB</code>的函数<code>f</code>），实际上，这里并不是直接调用<code>f</code>，而是加了一层封装，我们来看看<code>co_create</code>的代码：<br><img src="/img/blog/skynet_co_create.png" alt="img"></p><ol><li>从池子里取出一条协程。</li><li>池子里没有协程时，创建协程。</li><li>协程的主函数，首先执行<code>f</code>(即传入的<code>dispatch</code>函数)。</li><li>执行完成之后，判断当前协程是否记录着session，当调用<code>skynet.ret</code>时，会清掉这个session。如果此时的<code>session</code>不等于0，就表示收到一个<code>call</code>之后没有使用<code>skynet.ret</code>返回，就在这里报个错。</li><li>清理数据。</li><li>将当前协程放入池子里，等待循环使用。</li><li>将协程挂起。</li><li>下一将调用<code>co_create</code>时，如果能从池子里找到<code>co</code>，则在这里开始执行协程，传入<code>f</code>，继续执行。</li></ol><h3 id="延迟返回">延迟返回</h3><p>一般情况下，在处理call消息的协程中，我们必须调用<code>skynet.retpack</code>来返回数据，否则的话，会报错误<code>Maybe forgot response</code>。<br>但有些情况下，我们希望在其他协程中返回数据(例如<a href="!https://blog.supersource.top/skynet_new_service/">skynet.newservice 简介：服务的启动</a>讲到的launch)，这时候，我们可以使用<code>skynet.response</code>来生成一个响应函数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skynet.response</span><span class="hljs-params">(pack)</span></span><br>pack = pack <span class="hljs-keyword">or</span> skynet.pack<br><br><span class="hljs-keyword">local</span> co_session = <span class="hljs-built_in">assert</span>(session_coroutine_id[running_thread], <span class="hljs-string">&quot;no session&quot;</span>)<br>session_coroutine_id[running_thread] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">local</span> co_address = session_coroutine_address[running_thread]<br><span class="hljs-keyword">if</span> co_session == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br><span class="hljs-comment">--  do not response when session == 0 (send)</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">response</span><span class="hljs-params">(ok, ...)</span></span><br><span class="hljs-keyword">if</span> ok == <span class="hljs-string">&quot;TEST&quot;</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> unresponse[response] ~= <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pack <span class="hljs-keyword">then</span><br><span class="hljs-built_in">error</span> <span class="hljs-string">&quot;Can&#x27;t response more than once&quot;</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> ret<br><span class="hljs-keyword">if</span> unresponse[response] <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> ok <span class="hljs-keyword">then</span><br>ret = c.send(co_address, skynet.PTYPE_RESPONSE, co_session, pack(...))<br><span class="hljs-keyword">if</span> ret == <span class="hljs-literal">false</span> <span class="hljs-keyword">then</span><br><span class="hljs-comment">-- If the package is too large, returns false. so we should report error back</span><br>c.send(co_address, skynet.PTYPE_ERROR, co_session, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>ret = c.send(co_address, skynet.PTYPE_ERROR, co_session, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">end</span><br>unresponse[response] = <span class="hljs-literal">nil</span><br>ret = ret ~= <span class="hljs-literal">nil</span><br><span class="hljs-keyword">else</span><br>ret = <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br>pack = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> ret<br><span class="hljs-keyword">end</span><br>unresponse[response] = co_address<br><br><span class="hljs-keyword">return</span> response<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里实际上就是把返回需要用到的<code>session</code>和<code>source</code>用作一个函数的<code>upValue</code>，并返回这个函数，同时，清除<code>session_coroutine_id</code>中当前<code>co</code>对应的<code>session</code>，这样就不会触发到<code>Maybe forgot response</code>的警告了。</p>]]></content>
    
    
    <categories>
      
      <category>skynet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏服务器</tag>
      
      <tag>skynet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows实现端口转发</title>
    <link href="/windows_port_forward/"/>
    <url>/windows_port_forward/</url>
    
    <content type="html"><![CDATA[<p>最近在做界面开发时，想要直接在手机上看看实际效果，由于我的服务器是放在虚拟机上的，所以需要在window上面做个端口转发，这就需要用到<code>netsh</code>命令。</p><h3 id="添加端口转发">添加端口转发</h3><p><code>netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.24.90</code><br>主要参数：</p><ul><li><code>v4tov4</code>：表示<code>IPv4</code>到<code>IPv4</code>的转发</li><li><code>listenport=8080</code>: 代理在本地机器上监听的端口号</li><li><code>listenaddress=0.0.0.0</code>: 代理在本地机器上监听的IP地址。<code>0.0.0.0</code>表示本机所有<code>IPv4</code>地址，即不管数据包是发送到哪个本地IPv4地址，只要是发送到<code>8080</code>端口的，都符合这个规则</li><li><code>connectport=80</code>:代理将流量转发到的目标端口</li><li><code>connectaddress=192.168.24.90</code>:代理将流量转发到的目标IP地址</li></ul><p>设置成功后，当本地机器收到任何发往<code>8080</code>端口的流量时，都会将这些流量转发到IP地址为<code>192.168.24.90</code>的机器上的<code>80</code>端口。</p><h3 id="删除端口转发">删除端口转发</h3><p>如果想要删除端口转发，可以使用以下指令，参数和添加时候一样：<br><code>netsh interface portproxy delete v4tov4 listenport=8080 listenaddress=0.0.0.0</code></p><h3 id="查看端口转发">查看端口转发</h3><p>添加端口转发后，可以使用以下命令查看已经设置的端口转发规则：<br><code>netsh interface portproxy show all</code><br>执行上述命令后，将看到类似以下的输出，显示当前配置的所有端口转发规则：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">侦听 IPv4 地址              侦听端口         连接 IPv4 地址       连接端口<br>---------------------  ----------      ----------------     ----------<br><span class="hljs-number">0.0.0.0</span>                     <span class="hljs-number">8080</span>          <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">24</span>.<span class="hljs-number">90</span>          <span class="hljs-number">80</span><br><span class="hljs-number">0.0.0.0</span>                    <span class="hljs-number">10001</span>          <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">24</span>.<span class="hljs-number">90</span>       <span class="hljs-number">10001</span><br></code></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><p>windows上做端口转发是非常简单的，值得注意的是，执行指令时，需要<strong>管理员权限</strong>。<br>此外，还需要对<strong>防火墙</strong>做设置，开放指定的端口，才能最终生效。</p><h3 id="UI界面">UI界面</h3><p>每次都需要输入指令比较麻烦，干脆让<code>ChatGPT</code>用<code>python</code>写个简单的小界面，直接在界面中查看和添加/删除端口转发，非常方便。<br>代码放在<a href="https://github.com/lcw4u/Windows-PortProxy-Manager">这里</a>，有兴趣的可以看看。</p><p><img src="/img/blog/window_port_forward.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP的滑动窗口和拥塞控制</title>
    <link href="/TCP_sliding_window_congestion_window/"/>
    <url>/TCP_sliding_window_congestion_window/</url>
    
    <content type="html"><![CDATA[<p>当我们使用TCP，从客户端发送数据到服务器，这个过程会是怎样的呢？<br>首先，当然是耳熟能详的<a href="https://blog.supersource.top/the_three_way_handshake_of_TCP/">三次握手过程</a>，那当连接建立之后，就一股脑发送所有数据吗？<br>当然不是，一下子发送太多数据，接收端可能没有那么大的空间，就浪费了流量。<br>TCP使用<strong>滑动窗口</strong>来管理发送方和接收方之间的数据传输量。滑动窗口通过控制未确认数据包的数量，确保发送方发出的包不会超出接收方的处理能力。</p><h3 id="滑动窗口">滑动窗口</h3><p>滑动窗口的工作机制如下：</p><ul><li>TCP在每个ACK包中，通知对方自己目前能接收多少数据，即TCP头部中的<strong>窗口大小</strong>(三次握手期间的ACK也会包含窗口大小)。</li><li>发送方可以在这个<strong>窗口大小</strong>内，<strong>连续</strong>发送多个数据包，而不必等待每个数据包的确认。</li><li>当发送方收到接收方的<code>ACK</code>确认，窗口就会向前滑动，允许发送方继续发送新的数据包。</li></ul><p>在某个时间段，发送方的TCP数据流如下图所示，可以分成4个部分：<br><img src="/img/blog/tcp_swnd.png" alt="image"></p><ul><li>已发送且已确认的数据：这部分数据已经没用了，不再需要保存。</li><li>已发送但未确认的数据：需要保存在缓冲区里，如果丢包了，可以进行重传。</li><li>未发送，允许发送的数据：没有超过接收方缓冲区，可以发送数据。</li><li>未发送，不允许发送的数据：超过对方缓冲区，不可以发送。</li></ul><p>滑动窗口的优点：</p><ul><li>高效利用带宽：滑动窗口允许发送方连续发送多个数据包，而无需等待每个数据包的确认，从而提高了带宽利用率。</li><li>流量控制：通过动态调整窗口大小，滑动窗口机制能有效控制数据流量，防止网络拥堵。</li></ul><h3 id="窗口满的情况">窗口满的情况</h3><p>在接收方看来，数据可以分成三个部分：</p><ul><li>成功接收并确认的数据</li><li>未收到但可以接收的数据</li><li>未收到且不可接收的数据<br><img src="/img/blog/tcp_rwnd.png" alt="image"></li></ul><p>未收到但可以接收的部分，就是接收方的窗口大小。<br>接收方收到数据后，会存放到缓冲区中，等待上层应用获取数据(socket调用read函数)。<br>如果上层应用繁忙，读取效率较低，那么这个窗口就会慢慢变小，甚至会变成0，也就是窗口满的情况。<br>这时候，接收方会发送一个<code>ZeroWindow</code>的包，告诉发送方，这边已经不能再接收数据了，发送方就不再发送数据。<br>等到缓冲区的数据被读取之后，接收方会发一个<code>WindowUpdate</code>的ACK，告诉发送方自己最新的窗口大小，发送方就可以继续发送数据了。</p><p>但是这里有个问题，如果这个<code>WindowUpdate</code>的包丢失了的话，发送方就只能继续保持0窗口，数据在这里就卡住不再发送了。<br>为了解决这个问题，TCP设置了定时探测，发送<code>ZeroWindowProbe</code>，获取接收端最新的窗口大小。<br><img src="/img/blog/tcp_slide_window.png" alt="image"></p><blockquote><p>TCP协议本身并没有一个明确的<code>Window Full</code>标记。然而，在实际使用中，有些网络监测工具和协议分析器（例如Wireshark）会标识或标记某些数据包，以表明发送方的发送窗口已经完全被使用。这种标记主要是用来帮助用户理解和分析TCP连接中的流量控制和拥塞控制情况。</p></blockquote><h3 id="糊涂窗口综合症">糊涂窗口综合症</h3><p>当接收方缓冲区满时，窗口关闭，如果应用层读取了一个字节的数据，此时缓冲区就有了一个字节的空间，这时候立刻发送<code>WindowUpdate</code>通知发送方的话，那发送方就可能发一个字节的数据过来，一个TCP包只包含一个字节的数据，这效率就很低下。<br>这种情况下，这个连接的窗口一直保持在很小的状态，称作<code>糊涂窗口综合症</code>。<br>为了解决这个问题，当<code>窗口大小</code>小于<code>min(MSS，缓存空间/2)</code> ，也就是小于<code>MSS</code>与<code>1/2</code>缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。<br>等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，才更新窗口大小，让发送方发送数据过来。</p><h3 id="拥塞控制">拥塞控制</h3><p>滑动窗口控制的是一个TCP连接的流量，避免发送方的数据填满接收方的缓存。但是，网络上不只一个TCP连接，如果不加以控制的话，就可能发生数据的拥堵，拥堵导致丢包，丢包需要重传，则又加大了拥堵。<br>所以，TCP使用了<strong>拥塞控制</strong>来避免数据填满整个网络。</p><p><strong>拥塞窗口 cwnd</strong> 是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong> 。当<code>cwnd=n</code>时，表示发送方可以发送<code>n</code>个<code>MSS</code>大小的数据</p><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><h4 id="慢启动">慢启动</h4><p>慢启动的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加<code>cwnd</code>的大小，其算法如下：</p><ol><li>建立连接后，初始化<code>cwnd</code>为<code>1</code>，可以发送1个<code>MSS</code>数据。</li><li>每次收到<code>ACK</code>，则将<code>cwnd</code>加1。</li><li><code>cwnd</code>达到某一个阈值<code>ssthresh</code>（slow start threshold）后，不再使用慢启动，改用<strong>拥塞避免</strong>算法。</li></ol><p><img src="/img/blog/tcp_slow_start.png" alt="image"><br>从上图中，可以看到，每一个<code>rtt</code>时间，<code>cwnd</code>都会翻倍，从而快速地增长。在良好的网络环境下，可以很快达到阈值，进入<strong>拥塞避免</strong>算法。</p><blockquote><p>在一些现代操作系统中（如 Linux 和 Windows），TCP 初始拥塞窗口的默认值为 10 个 MSS。这使得发送方在建立连接后的初始数据传输中，可以一次发送多达 10 个 MSS 的数据包，而不必经历传统的慢启动阶段。</p></blockquote><h4 id="拥塞避免">拥塞避免</h4><p>慢启动时，起点低，但指数增长，速度快，达到一定程度后，就不能再继续指数增长，以防止拥塞。拥塞避免的想法就是，在一个<code>rtt</code>时间内，让<code>cwnd</code>不是翻倍，而是加一，缓慢增长。<br>那么，如何让<code>cwnd</code>在一个<code>rtt</code>中加一呢？在<strong>慢启动</strong>算法中，在某一轮次，<code>cwnd=n</code>，此时连续发送<code>n</code>个<code>MSS</code>，每次收到<code>ACK</code>则<code>cwnd+1</code>，收到<code>n</code>个则<code>cwnd+n</code>，形成翻倍的效果。同理，只要在每次收到<code>ACK</code>时，将<code>cwnd+1</code>改成<code>cwnd+1/n</code>，那么在<code>n</code>个<code>ACK</code>后，则形成<code>cwnd+1</code>的结果。</p><p>在慢启动和拥塞避免阶段，如果出现超时，则重发超时的数据，然后处理如下：</p><ul><li>将<code>ssthresh</code>设为<code>cwnd/2</code></li><li>将<code>cwnd</code>设为1</li><li>进入<strong>慢启动</strong>算法</li></ul><h4 id="快速重传">快速重传</h4><p>当检测是否丢包时，每次都要等待超时的发生，会浪费很长时间，因此引入了<strong>快速重传</strong>：发送方只要收到3个重复的<code>ACK</code>，即认为丢包发生，此时会立即重传丢失的包，而不再等待超时的出现。</p><h4 id="快速恢复">快速恢复</h4><p>为了解决丢包后进入<strong>慢启动</strong>引起的效率降低，在<strong>快速重传</strong>的基础上，又引入了<strong>快速恢复</strong>，在发生快速重传之后，拥塞控制如下处理：</p><ul><li>将<code>ssthresh</code>设为<code>cwnd/2</code>。</li><li>将<code>cwnd</code>设为<code>ssthresh+3</code>（+3是因为已经收到3个重复的ACK）。</li><li>如果再收到重复的ACK，则<code>cwnd+1</code>。</li><li>如果收到新的ACK，则快速恢复结束，进入<strong>拥塞避免</strong>。</li></ul><h3 id="参考资料">参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/612561398">知乎 - 笔记：滑动窗口</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP:Nagle算法和延迟确认</title>
    <link href="/TCP_Nagle_and_Delayed_ACK/"/>
    <url>/TCP_Nagle_and_Delayed_ACK/</url>
    
    <content type="html"><![CDATA[<p>Nagle 算法（Nagle’s Algorithm）和延迟确认（Delayed ACK）是两种用于提高 TCP 协议性能的机制。它们旨在减少网络中的<strong>小数据包</strong>数量，从而提高网络效率。然而，这两种机制有时也会相互影响，导致性能问题。</p><h3 id="Nagle算法">Nagle算法</h3><p>Nagle算法作用于发送端，其目的在于通过减少小数据包的发送，来减少网络的拥塞。<br>在讲解<a href="https://blog.supersource.top/the_three_way_handshake_of_TCP/">TCP三次握手</a>的时候，我们提到TCP头部结构，其大小为20~60个字节。设想一下，如果我们要发送一个字节的数据，为了这一个字节，我们需要加上20字节的TCP头部，再加了20字节的IP头部，一共40字节的头部，就为了搭载这一个字节的数据，显得效率太低，于是就有了Nagle算法：</p><ul><li>发送数据时，如果当前有<strong>尚未确认</strong>的数据(已发出数据但还没收到ACK)，则将数据缓存起来。</li><li>当<strong>所有</strong>未确认的数据都被确认后，TCP会发送缓冲区中的数据。</li><li>如果缓冲区的数据大于<code>MSS</code>时，也会直接发送缓冲区的数据。</li></ul><blockquote><p><code>MSS（Maxinum Segment Size）</code>指最大报文段长度，<code>MSS</code>的常见计算方式为 <code>MTU</code>（最大传输单元）减去20字节的TCP头部和20字节的IP头部，通常<code>MSS</code>值设置为<code>1460</code>字节。这个值有助于避免 IP 分片。</p></blockquote><p><img src="/img/blog/TCP_Nagle.png" alt=""><br>当启用Nagle算法的时候，我们发送多个小包，就会被合成一个大包，以及来减少网络中数据包的数量。但是，对于实时性要求较高的应用，这样做相当于带来延迟，并不适合。<br><img src="/img/blog/TCP_Nagle_wireshark.png" alt=""><br>我们可以通过设置<code>TCP_NODELAY</code>选项来关闭Nagle算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> enable = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">setsockopt</span>(sock, IPPROTO_TCP, TCP_NODELAY, &amp;enable, <span class="hljs-built_in">sizeof</span>(enable));<br></code></pre></td></tr></table></figure><h3 id="延迟确认">延迟确认</h3><p>Nagle算法是从发送端减少包的数据，而<strong>延迟确认</strong>则是从接收方的角度，通过减少<code>ACK</code>的数量，还达到减少网络拥塞的目的。</p><ul><li>当<code>TCP</code>收到数据包后，不立即发送<code>ACK</code>，而是等待一小段时间（通常是 200 毫秒）。</li><li>在这个等待时间内，如果有数据需要发送，则将<code>ACK</code>和数据一起发送，这样可以减少单独的<code>ACK</code>包。</li><li>在这个等待时间内，如果收到第二份数据，则发送<code>ACK</code>。</li><li>如果等待时间到期，还没有数据要发送，则发送<code>ACK</code>。</li></ul><p>TCP 连接中，客户端发送数据包，服务器收到后，如果立即发送 ACK，网络中会有大量的 ACK 包。启用延迟确认后，服务器在接收数据包后会等待一段时间，如果在这段时间内客户端继续发送数据，服务器可以一起确认多个数据包，减少 ACK 包数量。</p><h3 id="Nagle算法和延迟确认导致的性能问题">Nagle算法和延迟确认导致的性能问题</h3><p>Nagle在发送数据的环节增加了延迟，而延迟确认在接收的环节增加了延迟，如果发送方一直发小包，而接收方也没有数据返回的时候，可能会造成更多的延迟：<br><img src="/img/blog/TCP_Nagle_delay_ack.png" alt=""><br>所以，在对延迟比较敏感的应用中，通常会关闭<code>Nagle</code>算法，来提高延迟。</p><h4 id="参考资料">参考资料</h4><ul><li><a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">维基百科-Nagle算法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP的重传机制</title>
    <link href="/TCP_retransmission_mechanism/"/>
    <url>/TCP_retransmission_mechanism/</url>
    
    <content type="html"><![CDATA[<p>TCP 是一个<strong>可靠</strong>的传输协议，解决了IP层的<strong>丢包、乱序、重复</strong>等问题。这其中，TCP的<strong>重传机制</strong>起到重要的作用。</p><h3 id="序列号和确认号">序列号和确认号</h3><p>之前我们在讲解<a href="https://blog.supersource.top/the_three_way_handshake_of_TCP/">TCP三次握手</a>时，提到过TCP包头结构，其中有<strong>序列号</strong>和<strong>确认号</strong>，<br>而TCP 实现可靠传输的方式之一，就是是通过序列号和确认应答。</p><ol><li><p>序列号(Sequence Number):</p><ul><li>TCP是基于<strong>数据流</strong>的，序列号用于标识数据流中的字节位置，它表示数据包中的第一个字节在整个数据流中的位置。</li><li>接收方在接收到数据包后，会根据序列号对数据包进行排序和重组，确保数据的<strong>顺序正确</strong>。</li></ul></li><li><p>确认号(Acknowledgement Number)：</p><ul><li><p>确认号用于确认接收方已经成功接收了数据，并且期望下一个接收到的数据包的序列号是多少。</p></li><li><p>在TCP通信中，接收方会向发送方发送一个确认数据包，其中包含了确认号，表示接收到的数据包中的最后一个字节的下一个字节的序列号。</p><p><img src="/img/blog/tcp_seq_ack1.png" alt="确认和应答"></p></li></ul></li></ol><p>我们可以用wireshark抓包来看一下TCP的序列号和确认号：<br><img src="/img/blog/tcp_seq_1.png" alt="seq"><br>通过上图我们可以看到：</p><ol><li>进行三次握手时，客户端的初始序列号是2924706275，服务端的初始序列号是1859008164。</li><li>发送第一个包时，序列号是2924706276，是初始序列号+1，表示当前数据是第一个字节，数据长度8字节。</li><li>服务端回复ACK时，确认号是2924706284，是客户端的初始序列号+9，表示已经接收到前8个字节，现在期待第9个字节。</li><li>客户端继续发第二个包，序列号2924706284，表示当前数据是第9个字节。</li><li>服务端回复ACK时，确认号是2924706292，是客户端的初始序列号+17，表示已经接收到前16个字节，现在期待第17个字节。</li></ol><p>在wireshark中，可以显示相对的序列号，可以更直观地看到序列号的变化：<br><img src="/img/blog/tcp_seq_2.png" alt="seq"></p><p>这里我们可以看到，服务端发的包，序列号一直是1，因为当前服务端只是接收数据，并没有发送数据，所以服务端的序列号一直是1，而客户端的确认号也一直是1，表示期待服务端发送第一个字节过来。</p><h3 id="重传机制">重传机制</h3><p>正常情况下，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。<br>但在复杂的网络下，并不一定能顺利的进行数据传输，万一数据在传输过程中丢失了呢？针对数据包丢失的情况，TCP会用<strong>重传机制</strong>解决。</p><h4 id="超时重传">超时重传</h4><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，如果还没有收到对方的ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。<br><img src="/img/blog/tcp_retransmission2.png" alt="超时重传"><br>那么这个指定的时间，应该是多久比较合适呢？<br>这里先介绍两个概念：<code>RTT</code>和<code>RTO</code></p><ul><li><code>RTT</code>(Round-Trip Time) 往返时延，指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间</li><li><code>RTO</code>(Retransmission Timeout)，就是超时重传时间。</li></ul><p>通常<code>RTO</code>应该略大于<code>RTT</code>：</p><ul><li>如果<code>RTO</code>太短，有可能数据没有丢失就重发，增加网络拥塞。</li><li>如果<code>RTO</code>太长，重发就慢，性能差。</li></ul><p>由于网络的不稳定，<code>RTT</code>是经常变化的，导致<code>RTO</code>也会是一个动态变化的值。</p><p>如果超时重发的数据，再次超时的话，下一次重传的时间间隔则会加倍。<br>超时重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p><p>TCP用<strong>快速重传</strong>机制来解决超时重发的时间等待。</p><h4 id="快速重传">快速重传</h4><p>发送方发包的时候，并不总是等待ACK的响应再发送下一个包，而是会在窗口大小内，连续发多个包：<br><img src="/img/blog/tcp_seq_ack2.png" alt="累积确认"><br>如果其中一个包丢失了，而后续的包到达时，接收方会发丢失的包的ACK给发送方。当发送方连接收到三个相同的ACK时，就知道这个包丢失了，于是不用等重传定时，直接就可以重新发送了：<br><img src="/img/blog/tcp_fast_retransmission1.png" alt="快速重传"></p><p>通过wireshark抓包，在过滤器中输入<code>tcp.analysis.fast_retransmission</code>，我们可以观察到快速重传的现象：<br><img src="/img/blog/wireshark_fast_retransmission1.png" alt="快速重传"><br><img src="/img/blog/wireshark_fast_retransmission2.png" alt="快速重传"></p><h4 id="SACK">SACK</h4><p>快速重传机制解决了超时时间的问题，但是它面临着另外一个问题：那就是重传的时候，是重传一个包，还是重传所有的包？像上面的例子，客户端发出19个包，当触发快速重传的时候，客户端只知道第2个包丢失了，那其他包是否丢失，客户端并不清楚，这时候有两种选择：</p><ul><li>重发2~19所有的包，显然会造成数据的浪费，因为后面17个包都是已经收到的。</li><li>只重发第2个包。但如果第3个包也丢失的话，那么又得等到三次ACK才能重发第3个包，效率较低。</li></ul><p>这时候，<code>SACK(Selective Acknowledgment)</code>，选择性确认，就可以起作用了。<br>这种方式需要在TCP头部<strong>选项</strong>字段里加一个<code>SACK</code>的选项，它可以将已收到的数据的信息发送给发送方 ，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据了 。<br><img src="/img/blog/tcp_sack.png" alt="SACK"><br>在这个例子中，<code>SACK</code>表示<code>15870601~15873581</code>之间的数据是已经收到的，所以客户端只需要重发<code>15869201~15870600</code>之间的数据就行了。</p><blockquote><p>由于TCP头部大小的限制，在选项中最多能支持四组SACK的数据</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>skynet.newservice简介：服务的启动</title>
    <link href="/skynet_new_service/"/>
    <url>/skynet_new_service/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/cloudwu/skynet/wiki">skynet</a>是一个轻量级的游戏服务器框架。</p></blockquote><h3 id="简介">简介</h3><p>在<code>skynet</code>的体系中，<strong>服务</strong>是一个基础概念。通常，我们使用<code>skynet.newservice</code>来启动一个<code>snlua</code>服务。<br>那么，当我们写下<code>local addr = skynet.newservice(&quot;test&quot;)</code>这行代码时，系统是怎么运作的呢？<br>思考一下这些问题：</p><ul><li>调用<code>skynet.newservice</code>会不会发生阻塞？</li><li>如果<code>test</code>服务在<code>skynet.start</code>时调用了<code>skynet.exit</code>，<code>addr</code>会是什么值？</li><li>如果<code>test</code>服务在<code>skynet.start</code>时出现错误，<code>addr</code>又会是什么值？</li><li><code>test</code>服务是不是一定要调用<code>skynet.start</code>？</li><li>如果要传一些复杂的参数，又要怎么做？</li></ul><h3 id="skynet-newservice的代码实现">skynet.newservice的代码实现</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--skynet/lualib/skynet.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skynet.newservice</span><span class="hljs-params">(name, ...)</span></span><br><span class="hljs-keyword">return</span> skynet.call(<span class="hljs-string">&quot;.launcher&quot;</span>, <span class="hljs-string">&quot;lua&quot;</span> , <span class="hljs-string">&quot;LAUNCH&quot;</span>, <span class="hljs-string">&quot;snlua&quot;</span>, name, ...)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>skynet.newservice</code>的代码很简单，只调用了一个<code>skynet.call</code>，而<code>skynet.call</code>是阻塞的，所以<code>skynet.newservice</code>也是阻塞的。<br>这个<code>call</code>发了一条<code>lua</code>消息给<code>.launcher</code>服务，接下来看看<code>.launcher</code>服务相关的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--skynet/service/launcher.lua</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">launch_service</span><span class="hljs-params">(service, ...)</span></span><br><span class="hljs-keyword">local</span> param = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(&#123;...&#125;, <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">local</span> inst = skynet.launch(service, param)<br><span class="hljs-keyword">local</span> session = skynet.context()<br><span class="hljs-keyword">local</span> response = skynet.response()<br><span class="hljs-keyword">if</span> inst <span class="hljs-keyword">then</span><br>services[inst] = service .. <span class="hljs-string">&quot; &quot;</span> .. param<br>instance[inst] = response<br>launch_session[inst] = session<br><span class="hljs-keyword">else</span><br>response(<span class="hljs-literal">false</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> inst<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command.LAUNCH</span><span class="hljs-params">(_, service, ...)</span></span><br>launch_service(service, ...)<br><span class="hljs-keyword">return</span> NORET<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里又调用到<code>skynet.launch</code>，实际上是发了个<code>LAUNCH</code>指令到底层，这里创建了一个<code>snlua</code>服务：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--skynet/lualib/skynet/manager.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skynet.launch</span><span class="hljs-params">(...)</span></span><br><span class="hljs-keyword">local</span> addr = c.command(<span class="hljs-string">&quot;LAUNCH&quot;</span>, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(&#123;...&#125;,<span class="hljs-string">&quot; &quot;</span>))<br><span class="hljs-keyword">if</span> addr <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">tonumber</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(addr , <span class="hljs-number">2</span>), <span class="hljs-number">16</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>要注意前面的<code>.launcher</code>服务的<code>command.LAUNCH</code>函数是忽略返回的，所以此时<code>skynet.newservice</code>还处于阻塞状态，等待<code>.launcher</code>的返回。<br>那什么时候会返回响应呢？</p><p>回到前面的<code>launch_service</code>函数，可以看到<code>skynet.launch</code>成功后并没有直接返回，而是生成一个响应函数<code>response</code>，存储在表<code>instance</code>中。<br>搜索这个<code>instance</code>，我们可以在<code>command.LAUNCHOK</code>中找到它的使用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--skynet/service/launcher.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command.LAUNCHOK</span><span class="hljs-params">(address)</span></span><br>    <span class="hljs-comment">-- init notice</span><br>    <span class="hljs-keyword">local</span> response = instance[address]<br>    <span class="hljs-keyword">if</span> response <span class="hljs-keyword">then</span><br>        response(<span class="hljs-literal">true</span>, address)<br>        instance[address] = <span class="hljs-literal">nil</span><br>        launch_session[address] = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> NORET<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>也就是说，要等到<code>.launcher</code>服务收到<code>LAUNCHOK</code>的指令之后，才会返回给<code>newservice</code>的调用者。<br>问题又来了，什么时候发送<code>LAUNCHOK</code>呢？答案是在<code>skynet.init_service</code>中。</p><p>而调用<code>skynet.init_service</code>的，一共有三个函数：</p><ul><li>skynet.start</li><li>skynet.forward_type</li><li>skynet.filter</li></ul><p>所以，在服务的启动脚本中，我们必须调用这三个函数中的其中一个（通常都是<code>skynet.start</code>），否则的话，调用方永远都收不到返回的数据。<br>以在<code>main</code>服务中，创建新服务<code>test</code>为例，流程如下图所示：<br><img src="/img/blog/skynet_service.png" alt="skynet.service"></p><h3 id="新服务启动时，调用skynet-exit，调用者收到的addr是什么？">新服务启动时，调用skynet.exit，调用者收到的addr是什么？</h3><p>我们看一下<code>skynet.exit</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">--skynet<span class="hljs-regexp">/lualib/</span>skynet.lua<br><span class="hljs-keyword">function</span> skynet.<span class="hljs-keyword">exit</span>()<br>fork_queue = &#123; h = <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span> &#125;-- no fork coroutine can be execute after skynet.<span class="hljs-keyword">exit</span><br>skynet.send(<span class="hljs-string">&quot;.launcher&quot;</span>,<span class="hljs-string">&quot;lua&quot;</span>,<span class="hljs-string">&quot;REMOVE&quot;</span>,skynet.self(), false)<br><br>--其他代码...<br>--...<br>end<br></code></pre></td></tr></table></figure><p>这里看到，新服务发送了<code>REMOVE</code>指令到<code>.launcher</code>服务，而<code>.launcher</code>对<code>REMOVE</code>的处理如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--skynet/service/launcher.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command.REMOVE</span><span class="hljs-params">(_, handle, kill)</span></span><br>services[handle] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">local</span> response = instance[handle]<br><span class="hljs-keyword">if</span> response <span class="hljs-keyword">then</span><br><span class="hljs-comment">-- instance is dead</span><br>response(<span class="hljs-keyword">not</span> kill)<span class="hljs-comment">-- return nil to caller of newservice, when kill == false</span><br>instance[handle] = <span class="hljs-literal">nil</span><br>launch_session[handle] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- don&#x27;t return (skynet.ret) because the handle may exit</span><br><span class="hljs-keyword">return</span> NORET<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>对于刚启动的服务来说，这里会调用到对应的<code>response</code>，<code>response</code>需要两个参数，这里第一个参数是<code>true</code>，第二个参数为<code>nil</code>，而第二个参数是返回地址，也就是说，调用者收到的<code>addr</code>是<code>nil</code>值。<br><img src="/img/blog/skynet_service_exit.png" alt="skynet.exit"></p><h3 id="新服务启动报错的话，又返回什么呢">新服务启动报错的话，又返回什么呢</h3><p>新服务启动的时候，无论是用<code>skynet.start</code>还是<code>skynet.forward_type</code>，最终都是调用<code>skynet.init_service</code>，来看看代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--skynet/lualib/skynet.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skynet.init_service</span><span class="hljs-params">(start)</span></span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>skynet_require.init_all()<br>start()<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> ok, err = <span class="hljs-built_in">xpcall</span>(main, <span class="hljs-built_in">traceback</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;init service failed: &quot;</span> .. <span class="hljs-built_in">tostring</span>(err))<br>skynet.send(<span class="hljs-string">&quot;.launcher&quot;</span>,<span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;ERROR&quot;</span>)<br>skynet.<span class="hljs-built_in">exit</span>()<br><span class="hljs-keyword">else</span><br>skynet.send(<span class="hljs-string">&quot;.launcher&quot;</span>,<span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;LAUNCHOK&quot;</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>可以看到，对<code>start</code>函数的调用，是通过<code>xpcall</code>来调用的，如果报错的话，会发送<code>ERROR</code>到<code>.launcher</code>服务。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--skynet/service/launcher.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command.ERROR</span><span class="hljs-params">(address)</span></span><br><span class="hljs-comment">-- see serivce-src/service_lua.c</span><br><span class="hljs-comment">-- init failed</span><br><span class="hljs-keyword">local</span> response = instance[address]<br><span class="hljs-keyword">if</span> response <span class="hljs-keyword">then</span><br>response(<span class="hljs-literal">false</span>)<br>launch_session[address] = <span class="hljs-literal">nil</span><br>instance[address] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br>services[address] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> NORET<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里<code>response</code>参数是<code>false</code>，<code>response</code>是<code>skynet.response</code>生成的一个函数，相关代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--skynet/lualib/skynet.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skynet.response</span><span class="hljs-params">(pack)</span></span><br>    <span class="hljs-comment">--其他代码...</span><br>    <span class="hljs-comment">--...</span><br>    <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">response</span><span class="hljs-params">(ok, ...)</span></span><br>        <span class="hljs-comment">--其他代码...</span><br>        <span class="hljs-comment">--...</span><br>        <span class="hljs-keyword">if</span> ok <span class="hljs-keyword">then</span><br>            ret = c.send(co_address, skynet.PTYPE_RESPONSE, co_session, pack(...))<br>            <span class="hljs-keyword">if</span> ret == <span class="hljs-literal">false</span> <span class="hljs-keyword">then</span><br>                <span class="hljs-comment">-- If the package is too large, returns false. so we should report error back</span><br>                c.send(co_address, skynet.PTYPE_ERROR, co_session, <span class="hljs-string">&quot;&quot;</span>)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span><br>            ret = c.send(co_address, skynet.PTYPE_ERROR, co_session, <span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-comment">--其他代码...</span><br>        <span class="hljs-comment">--...</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">--其他代码...</span><br>    <span class="hljs-comment">--...</span><br><br>    <span class="hljs-keyword">return</span> response<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>可以看到，当传入的<code>ok</code>是<code>false</code>的时候，会发送一个<code>PTYPE_ERROR</code>类型的消息给调用者。<br>而当我们<code>require&quot;skynet&quot;</code>时，对<code>PTYPE_ERROR</code>默认的处理函数是<code>_error_dispatch</code>，具体的流程可以看看源码，这里简而言之，就是调用<code>call</code>的那条协程会触发一个<code>call fail</code>的<code>error</code>。</p><p>所以，当新服务的启动函数出错时，在新服务中会报错，中断，而调用者在<code>skynet.call()</code>中也会报<code>call fail</code>的错，从而中断执行，也就不会有<code>addr</code>的返回了。<br><img src="/img/blog/skynet_service_error.png" alt="skynet.newservice.error"></p><h3 id="如果启动服务要传比较复杂的参数，要怎么做比较好">如果启动服务要传比较复杂的参数，要怎么做比较好</h3><p><code>skynet.newservice(service_name, ...)</code>后面是可以带多个参数的，但这些参数只能是数字或字符串，回看前面的<code>skynet.launch</code>的代码，里面是调用了<code>c.command(&quot;LAUNCH&quot;, table.concat(&#123;...&#125;,&quot; &quot;))</code>，这里可以看到，传递的参数通过<code>table.concat</code>打包成字符串，以空格隔开。如果我们的参数中带有空格，或者我们想要传个<code>table</code>，那就不支持了。<br>通常来说，我们可以先启动服务，在<code>skynet.start</code>中做些简单的功能，调用<code>skynet.dispatch(&quot;lua&quot;, ...)</code>来处理<code>lua</code>消息，通过<code>lua</code>消息来做初始化，这样就能传送复杂的参数了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> addr  = skynet.newservice(<span class="hljs-string">&quot;test&quot;</span>)<br>skynet.send(addr, <span class="hljs-string">&quot;lua&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, &#123;address=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,port=<span class="hljs-number">8888</span>,nodelay=<span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>现在，我们可以回答最初的问题了：</p><ul><li><p>调用<code>skynet.newservice</code>会不会发生阻塞？</p><ul><li>会阻塞，如果服务没启动完，会一直等待下去。</li></ul></li><li><p>如果<code>test</code>服务在<code>start</code>时调用了<code>exit</code>，<code>addr</code>会是什么值？</p><ul><li>nil</li></ul></li><li><p>如果<code>test</code>服务在<code>start</code>时出现错误，<code>addr</code>又会是什么值？</p><ul><li>skynet.newservice会报错，没有返回值</li></ul></li><li><p><code>test</code>服务是不是一定要调用<code>skynet.start</code>？</p><ul><li>不一定，也可以调用<code>skynet.forward_type</code>或<code>skynet.filter</code></li></ul></li><li><p>如果要传一些复杂的参数，又要怎么做？</p><ul><li>将服务的创建和启动分开，创建后发送<code>lua</code>消息初始化服务。</li></ul></li></ul><p>最后再思考一个问题：启动系统的时候，第一个服务又是什么时候启动的呢？答案可以看看这里：<a href="https://blog.supersource.top/skynet_main_service_bootstrap/">skynet 之 main 服务的启动</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏服务器</tag>
      
      <tag>skynet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP的四次挥手过程</title>
    <link href="/four_way_handshake_of_tcp/"/>
    <url>/four_way_handshake_of_tcp/</url>
    
    <content type="html"><![CDATA[<p><code>TCP</code>连接是双向传输的对等的模式（全双工模式），就是说双方都可以同时向对方发送或接收数据。<br>而断开的时候，也是双方都可以主动断开，此时需要经过四次挥手的过程，流程如下图所示：<br><img src="/img/blog/four_way_handshake_of_TCP.png" alt="TCP四次挥手"></p><ol><li>主动方发送<code>FIN</code>包给被动方，主动方状态变成<code>FIN_WAIT_1</code>，等待被动方的确认。此时主动方不能再发送数据。</li><li>被动方收到<code>FIN</code>之后，返回<code>ACK</code>包给主动方，确认自己收到这个包，被动方状态变成<code>CLOSE_WAIT</code>，等待关闭连接(等待缓存数据都发送过去)</li><li>主动方收到<code>ACK</code>之后，状态变成<code>FIN_WAIT_2</code>，等待被动方的<code>FIN</code>包。</li><li>被动方将缓冲区剩余的数据发送给主动方。</li><li>被动方发送<code>FIN</code>给主动方，被动方状态变成<code>LAST_ACK</code>状态。</li><li>主动方收到<code>FIN</code>之后，返回<code>ACK</code>包给被动方，主动方变成<code>TIME_WAIT</code>状态。</li><li>被动方收到<code>ACK</code>确认后，变成<code>CLOSE</code>状态。</li><li>主动方在经过<code>2MSL</code>时间之后，变成<code>CLOSE</code>状态。</li></ol><blockquote><p>MSL(Maximum Segment Lifetime)指报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><h3 id="为什么握手需要三次，而挥手需要四次？">为什么握手需要三次，而挥手需要四次？</h3><p>因为 <code>TCP</code>连接是全双工模式，一方断开连接，另一方还是可以继续发送数据，所以无法像三次握手一样，将 <code>FIN</code>和 <code>ACK</code>合并到一起，而是需要等待被动方处理完所有数据，不再有数据发送时，才会发送 <code>FIN</code>，来关闭被动方的连接。</p><h3 id="为什么需要-TIME-WAIT状态？">为什么需要 <code>TIME_WAIT</code>状态？</h3><p>需要 <code>TIME_WAIT</code> 状态，主要是两个原因：</p><ol><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收：<br>在连接关闭过程中，可能会存在一些延迟的数据包在网络中，这些数据包可能在连接关闭后到达目的地。<code>TIME_WAIT</code> 状态的存在可以确保在这段时间内不会接收到与当前连接相关的旧数据包，防止这些数据包造成连接的混乱。</li><li>保证「被动关闭连接」的一方，能被正确的关闭：<br>如果主动方收到 <code>FIN</code>，发出 <code>ACK</code>之后，直接进入 <code>CLOSE</code>状态，那么当这个 <code>ACK</code>丢失时，被动方收不到 <code>ACK</code>则会重发一个 <code>FIN</code>，但此时主动方已经是 <code>CLOSE</code>状态，无法再给被动方发送 <code>ACK</code>了。</li></ol><h3 id="如果两端同时关闭，会出现什么情况？">如果两端同时关闭，会出现什么情况？</h3><p>前面说过，<code>TCP</code>连接双方都可以主动断开，那如果两边同时断开，会怎样呢？<br><img src="/img/blog/tcp_close_in_the_same_time.png" alt="TCP同时断开"><br>从上图可以看到，一方发出<code>FIN</code>，进入<code>FIN_WAIT_1</code>状态，原本期待收到<code>ACK</code>，但此时收到了<code>FIN</code>，则会变成<code>CLOSING</code>状态，等到收到<code>ACK</code>时，再进入<code>TIME_WAIT</code>状态，同样要经过<code>2MSL</code>时间变成<code>CLOSE</code>状态。</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80">TCP连接断开 - 小林coding</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP的三次握手过程</title>
    <link href="/the_three_way_handshake_of_TCP/"/>
    <url>/the_three_way_handshake_of_TCP/</url>
    
    <content type="html"><![CDATA[<p><code>TCP</code>是<strong>面向连接</strong>的、<strong>可靠</strong>的、<strong>基于字节流</strong>的传输层通信协议。</p><p><code>TCP</code>是面向连接的协议，所以使用 <code>TCP</code>前必须先建立连接，而建立连接是通过三次握手来进行的。</p><h3 id="TCP包头结构">TCP包头结构</h3><p>在讲解<strong>三次握手</strong>的过程之前，我们先来看一下 <code>TCP</code>包的结构：<br><img src="/img/blog/tcp_package.png" alt="TCP包结构"><br><code>TCP</code>包头大小在大多数情况下是固定的，它通常是 <code>20</code>字节（不包括任何选项），但如果启用了选项，则最多可以达到 <code>60</code>字节。下面是 <code>TCP</code>包头的一般结构：</p><ul><li>源端口号（16位）：表示发送方的端口号。</li><li>目标端口号（16位）：表示接收方的端口号。</li><li>序列号（32位）：用于对数据流中的字节进行编号，以便对方能够按顺序重新组装数据。</li><li>确认号（32位）：表示期望接收到的下一个序列号。</li><li>数据偏移（4位）：指示 <code>TCP</code>包头的长度，以 <code>4字节</code>为单位。因此，数据偏移的值乘以 <code>4</code>就是 <code>TCP</code>包头的总长度。这个字段也被称为 <code>头部长度</code>。</li><li>保留位（6位）：保留供将来使用，目前全部为 0。</li><li>标志位（6位）：用于控制 <code>TCP</code>连接的状态，包括 <code>SYN</code>、<code>ACK</code>、<code>FIN</code>、<code>RST</code>、<code>PSH</code>、<code>URG</code>等。</li><li>窗口大小（16位）：表示发送方的接收窗口大小，用于流量控制。</li><li>校验和（16位）：用于验证 <code>TCP</code>报文的完整性。</li><li>紧急指针（16位）：当 <code>URG</code>标志被设置时，紧急指针表示紧急数据的末尾位置。</li><li>选项（可选）：可以包含各种选项，如最大报文段大小（<code>MSS</code>）、窗口缩放因子等，每个选项的大小不定。</li></ul><p>在三次握手过程中，我们主要关注<strong>序列号</strong>、<strong>确认号</strong>以及标志位中的<strong>SYN</strong>和<strong>ACK</strong></p><h3 id="三次握手过程">三次握手过程</h3><p>通常来说，服务器会开放监听端口，而客户端则主动连接这个端口，创建连接的时候，会进行三次握手，过程如下图所示：<br><img src="/img/blog/three_way_handshake_of_tcp.png" alt="TCP三次握手"></p><ol><li>客户端发送 <code>SYN</code>包到服务器，附上一个随机生成的序列号(<code>ISN</code>)。此时客户端处于 <code>SYN_SEND</code>状态。</li><li>服务器返回 <code>SYN+ACK</code>包到客户端，附上一个随机生成的序列号，确认号则是客户端上传的序列号+1。此时服务端处于<code>SYN_RECV</code>状态。</li><li>客户端返回 <code>ACK</code>到服务器，确认号是服务器下发的序列号+1。此时客户端处于<code>ESTABLISHED</code>状态，连接已建立，这个包可以顺带发一些数据。</li><li>服务端收到<code>ACK</code>后，也进入<code>ESTABLISHED</code>状态，可以收发数据。</li></ol><p>三次握手的一个重要功能是客户端和服务端交换 <code>ISN(Initial Sequence Number)</code>，以便让对方知道接下来接收数据的时候如何按序列号组装数据。同时也确保了服务端和客户端的收发都能正常进行。</p><p>使用 <code>wireshark</code>抓包工具，我们可以看到三次握手的数据：</p><p><img src="/img/blog/wireshark_tcp_three_way_handshake.png" alt="wireshark"></p><h3 id="为什么是三次握手？不是两次、四次？">为什么是三次握手？不是两次、四次？</h3><h4 id="1-TCP-连接使用三次握手的首要原因，是为了防止旧的重复连接初始化造成混乱。">1. TCP 连接使用三次握手的首要原因，是为了防止旧的重复连接初始化造成混乱。</h4><p>想像一个场景，客户端发了<code>SYN</code>之后宕机了，重启后又发了新的<code>SYN</code>。如果只有两次握手的话，当服务器收到旧的<code>SYN</code>之后，发送<code>ACK</code>给客户端，就直接进入<code>ESTABLISHED</code>状态，这时候就可以发数据了。</p><p>但是客户端期待的是新的<code>SYN</code>的序列号，发现服务端发的确认号不对应，会关闭这个连接，而服务器此时已经发了数据过来，这就造成了混乱。</p><p>而三次握手，客户端可以收到<code>ACK</code>之后，判断确认号，正确则返回<code>ACK</code>，错误则返回<code>RST</code>告诉服务器关闭这个连接。</p><p>使用三次握手和<code>RST</code>控制消息，将是否建立连接的最终控制权交给了客户端，因为只有客户端有足够的上下文来判断当前连接是否是错误的或者过期的，这也是<code>TCP</code>使用三次握手建立连接的最主要原因。</p><h4 id="2-三次握手的第二个原因，是为了交互双方的序列号。">2. 三次握手的第二个原因，是为了交互双方的序列号。</h4><p><code>TCP</code>协议的通信双方，都必须维护一个<strong>序列号</strong>，用来保证数据包的有序，以及丢包时能够重发，所以这个初始化的序列号是很重要的。当客户端发<code>SYN</code>给服务器时，服务器需要返回<code>ACK</code>确认，而服务器发<code>SYN</code>给客户端时，客户端也需要发<code>ACK</code>确认，才能确保两边都有正确的序列号。服务器在发<code>SYN</code>和<code>ACK</code>时，可以合并成一条消息发送，所以是不需要四次握手的。</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html">4.1 TCP 三次握手与四次挥手面试题 - 小林coding</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Redis实现游戏排行榜</title>
    <link href="/implementing_rank_using_redis/"/>
    <url>/implementing_rank_using_redis/</url>
    
    <content type="html"><![CDATA[<p>排行榜在当今应用中扮演着至关重要的角色。无论是游戏中的玩家排名、社交平台的用户活跃度榜单，还是其他领域的各种榜单，排行榜都是用户参与性和互动性的关键。在实现排行榜功能时，选择合适的数据库和数据结构至关重要。Redis，作为一种内存数据库，以其高性能和灵活性而备受青睐。下面将探讨如何使用Redis的有序集合（Sorted Set）来实现排行榜功能。</p><h3 id="1-Redis的有序集合">1 Redis的有序集合</h3><p>Redis是一种内存型数据库，查询效率高。Redis有一种数据结构叫有序集合（<code>Sorted Set</code>)，与普通集合相比，它的每个成员都关联一个分数，这个分数用于对成员进行排序。有序集合在插入和查询时都能够以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>的复杂度完成，这为排行榜的实现提供了高效的基础。有序集合不仅提供了快速的插入和查询操作，还支持范围查询，使得获取某个范围内的排名成员变得非常简单。</p><p>（关于Sorted Set如何实现高效的插入和查询，可以看我的这篇文章<a href="https://blog.supersource.top/skip_list_in_redis/">《Redis的跳跃表》</a>)</p><h3 id="2-使用有序集合实现排行榜">2 使用有序集合实现排行榜</h3><p>那么，我们要如何用Sorted Set来实现排行榜呢？</p><p>其实非常简单，首先根据需求，我们定义一个有序集合的key，例如：</p><ul><li>玩家等级的排行榜，我们可以用<code>rank:level</code>来作key值。</li><li>每天更新的排行榜，可以在后面加个日期<code>rank:level:0412</code></li><li>还有些比如是每天对指定BOSS的伤害排行，可以用<code>rank:damage:bossID:0412</code></li></ul><p>当排行数值改变的时候，我们用<code>zadd</code>指令来更新数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">zadd rank:level 玩家等级 玩家ID #参数是`score`和`member`<br></code></pre></td></tr></table></figure><p>也可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">ZINCRBY rank:level 10 lxx1 #使lxx1的积分增加10(如果lxx1在rank:level中不存在，则新增，设置积分为10)<br></code></pre></td></tr></table></figure><p>需要查询排行榜数据的时候，我们用<code>zrevrange</code>指令来获取数据(下标是从0开始)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">zrevrange</span> rank:level <span class="hljs-number">0</span> <span class="hljs-number">99</span> WITHSCORES    # 获取前<span class="hljs-number">100</span>名的ID和分数<br><span class="hljs-attribute">zrevrange</span> rank:level <span class="hljs-number">100</span> <span class="hljs-number">199</span> WITHSCORES # 获取<span class="hljs-number">101</span>-<span class="hljs-number">200</span>名的ID和分数<br><span class="hljs-attribute">zrevrange</span> rank:level <span class="hljs-number">0</span> <span class="hljs-number">99</span>               # 仅获取ID<br></code></pre></td></tr></table></figure><p>这里我们使用<code>zrevrange</code>，因为<code>zset</code>是按从小到大排序的，<code>zrevrange</code>是逆序返回<code>zset</code>中的数据。</p><p>取出玩家ID之后，我们再从另外的地方(<code>MySQL</code>、<code>redis</code>或者内存中)获取玩家的其他数据(名字，头像等），组合出完整的榜单数据。</p><p>查看排行玩家的排行和数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs redis">zscore rank:level lxx1 #获取玩家lxx1的分数<br>zrevrank rank:level lxx1 #获取玩家lxx1的排名<br></code></pre></td></tr></table></figure><p>如果要移除某个玩家的排行，可以使用<code>zrem</code>指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">zrem rank:level 玩家ID<br></code></pre></td></tr></table></figure><h3 id="3-实现数值相同时，按时间先后排序">3 实现数值相同时，按时间先后排序</h3><p>游戏排行榜中，经常有这样的需求：玩家等级相同时，按照到达这个等级的时间先后顺序排序。</p><p>使用Sorted Set时，我们可以将数值乘以一个系数，然后加上时间戳来实现这个功能。</p><p>比如，玩家等级<code>27</code>级，当前时间戳是<code>1705589522</code>，我们可以将这两个数组组合起来，由于时间戳是越小排序越前（和等级越大排序越前相反），我们使用相减的方式：</p><p><code>val = 27*1e10 + 1e10 - 1705589522</code></p><p>最终的结果是<code>278294410478</code>，其中前面的<code>27</code>表示等级，后面的<code>8294410478</code>是时间戳和<code>1e10</code>的差值（10位数的时间戳最大可以用到2086年，有生之年够用了），等级越大，这个值越大，而等级相同时，时间戳小的值更大。</p><p>值得注意的是，Sorted Set底层是使用<code>double</code>类型来存储数值，所以当排序的值过大时，加上这个时间戳可能就会不够精细。</p><p>通常来说，使用<code>double</code>能表示的精确的正整数可以达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>53</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{2}^{53}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">53</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>(<code>9007199254740991</code>16位数字)（关于这个值的计算，可以看我的另一篇文章<a href="https://blog.supersource.top/largest_accurately_integer_in_double_type/">《double 类型中可精确表达的最大正整数》</a>)</p><p>不过对于排行榜而言，如果本身的数值已经很大了，通常也不需要按照时间来排序了。比如BOSS伤害十几亿，这时候玩家连具体数值可能都看不到，通常也不会相同，用不着时间先后排序了。</p><h3 id="4-排行榜的合并">4 排行榜的合并</h3><p>合服的时候，使用<code>Sorted Set</code>也可以很方便的合并排行榜。</p><p>Redis提供了<code>并集(zunionstore)</code>操作，<code>并集</code>指的是将两个或多个<code>zset</code>中的元素合并为一个新的<code>zset</code>。</p><p>它的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]<br></code></pre></td></tr></table></figure><p>其中<code>destination</code>表示合并到的目标<code>key</code>，<code>numkeys</code>表示后面有多少个<code>key</code>要用来合并。例如有三个<code>key</code>需要合并：<code>rank:s1:level</code>、<code>rank:s2:level</code>、<code>rank:s3:level</code>，我们可以这样写：</p><p><code>ZUNIONSTORE rank:s1:level 3 rank:s1:level rank:s2:level rank:s3:level</code></p><p>表示将三个<code>key</code>合并，然后存储到<code>rank:s1:level</code>这个<code>key</code>中。</p><p>不过需要注意的是，在Redis的集群模式下，这样操作有可能会报错。（具体看这里<a href="https://blog.supersource.top/redis_cluster_slot/">《Redis 报错：CROSSSLOT Keys in request don’t hash to the same slot 的解决方案》</a>)。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis报错：CROSSSLOT Keys in request don&#39;t hash to the same slot的解决方案</title>
    <link href="/redis_cluster_slot/"/>
    <url>/redis_cluster_slot/</url>
    
    <content type="html"><![CDATA[<p>最近，项目上线的时候，出现了一个Redis的报错：<code>CROSSSLOT Keys in request don't hash to the same slot</code>，这个在内网环境下无法复现，因为正式环境的Redis是cluster集群模式，而我们内网环境是单机模式。(后面我在内网也部署了一个Redis集群，具体见我这一篇文章 <a href="https://blog.supersource.top/redis_cluster_use_docker/">《使用Docker搭建Redis Cluster集群》</a>）</p><h3 id="Redis集群的slot概念">Redis集群的slot概念</h3><p>Redis的插槽(<code>Slot</code>)是用于实现集群分片(<code>Cluster Sharding</code>)的一种机制。Redis集群至少需要三个结点，每个结点处理一部分数据。那么怎样分配这些数据到各个结点呢？Redis Cluster 采用的是虚拟槽分区算法，其中提到了槽（<code>Slot</code>）的概念。这个槽是用来存放缓存信息的单位，在 Redis 中将存储空间分成了 <code>16384</code> （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">{2}^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span class="mord">2</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span></span></span></span>）个槽，也就是说 Redis Cluster 槽的范围是 0 -16383。</p><p>在存储数据的时候，集群会对 Key 进行 CRC16 校验并对 16384 取模：</p><p><code>slot = CRC16(key) % 16384</code></p><p>得到的结果就是 Key-Value 所放入的槽，从而实现自动分割数据到不同的节点上</p><p><img src="/img/blog/redis-slot.png" alt="image"></p><blockquote><p>为什么会是16384个插槽呢？Redis作者是这么说的：<a href="https://github.com/redis/redis/issues/2576">传送门</a></p></blockquote><h3 id="什么情况下会报这个错">什么情况下会报这个错</h3><p>在集群模式下，所有涉及到多个 <code>key</code>的Redis指令，都要求所有的 <code>key</code>处于同一个 <code>slot</code>，如果 <code>slot</code>不同，哪怕实际上这些 <code>slot</code>都在同一个结点上，也会报这个错：</p><p><code>CROSSSLOT Keys in request don't hash to the same slot</code></p><p>例如以下这些操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs redis">SUNIONSTORE destination key [key ...]<br> SDIFF key [key ...]<br> EVAL script numkeys key [key ...] arg [arg ...]<br> DEL key [key ...]<br></code></pre></td></tr></table></figure><p>只要看到格式中有 <code>key [key ...]</code>这样的操作，在集群中，都必须保证所有 <code>key</code>在同一个 <code>slot</code>。</p><p>禁止不同的slot操作，大概有以下原因：</p><ol><li><strong>性能考虑</strong>：允许跨槽操作将需要在不同节点之间进行复杂的协调和网络通信，这可能会显著降低操作的性能。Redis设计为高性能的存储系统，这种设计选择有助于保持操作的速度和效率。</li><li><strong>简化分布式环境下的操作</strong>：通过限制操作仅在相同槽的键上执行，Redis Cluster简化了分布式环境下的数据管理。这样做减少了数据一致性和同步问题的复杂度，使得集群管理更为简单。</li><li><strong>提高可扩展性和可靠性</strong>：这种设计允许Redis Cluster在节点失败或网络分区发生时更容易地进行数据迁移和故障转移。如果允许跨槽操作，这将增加数据迁移和恢复的复杂性，可能会影响到整个系统的可靠性。</li><li><strong>分区的自治性</strong>：将数据划分到不同的槽中，并限制跨槽操作，有助于保证每个分区的自治性。这意味着每个节点可以独立处理其槽内的操作，从而减少了节点之间的依赖性。</li></ol><h3 id="要如何解决这个问题">要如何解决这个问题</h3><p>既然Redis集群不允许跨slot的操作，那我们只要让<code>key</code>强制分配到同一个<code>Slot</code>就行了。</p><p>上面说了，正常情况下，slot = CRC16(key)%16384，这里是对整个key进行CRC16。</p><p>Redis提供了一种<strong>Hash Tag</strong>的功能，在key中使用<code>&#123;&#125;</code>括起key中的一部分，在进行 CRC 16 (key) % 16384 的过程中，只会对<code>&#123;&#125;</code>内的字符串计算。</p><p>例如，<code>&#123;rank:level&#125;:1</code>,<code>&#123;rank:level&#125;:2</code>这两个key就会分配都同一个slot，因为计算哈希的时候，都使用了 <code>&#123;&#125;</code>中的那一部分:<code>rank:level</code>，所以分配出来的 <code>slot</code>就是一样的。</p><p>值得注意的是，这里的 <code>&#123;&#125;</code>可以放在key的任意位置，例如 <code>all&#123;rank:level&#125;</code>,<code>all&#123;rank:level&#125;:1</code>也都是一样的。</p><p>另外，如果有多个 <code>&#123;&#125;</code>的话，只有第一个 <code>&#123;&#125;</code>生效，例如 <code>&#123;rank:level&#125;:1:&#123;2&#125;</code>，用来计算哈希的只是第一个 <code>&#123;&#125;</code>里面的 <code>rank:level</code></p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://blog.csdn.net/qq_35872777/article/details/130010497">[CSDN]Redis中的插槽(slot)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>double类型中可精确表达的最大正整数</title>
    <link href="/largest_accurately_integer_in_double_type/"/>
    <url>/largest_accurately_integer_in_double_type/</url>
    
    <content type="html"><![CDATA[<p>之前在项目中，使用 <code>redis</code>的 <code>zset</code>来实现排行榜，由于 <code>zset</code>中的分数使用了 <code>double</code>类型，而我们排行的数值都是整数，所以引起一个问题：</p><ul><li>在 <code>double</code>中，能<strong>精确</strong>表示的，不会丢失精度的<strong>最大正整数</strong>是多少呢？</li></ul><p>先说结论：是  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>53</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{2}^{53}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">53</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，即 <code>9,007,199,254,740,991</code>。</p><h3 id="1-IEEE-754标准">1. IEEE 754标准</h3><p>在 <code>IEEE 754</code>标准中，规定了浮点数的二进制科学计数法，一个64位浮点数在内存中分为三个部分：</p><ul><li>符号位(<code>Sign</code>): <code>0</code>表示正数，<code>1</code>表示负数</li><li>指数位(<code>Exponent</code>): 科学计数法中的指数，采用移位存储</li><li>尾数部分(<code>Mantissa</code>): 有效数字</li></ul><p>根据 <code>IEEE754</code>标准，一个 <code>double</code>类型共64位(<code>0~63</code>)，其中最高位(<code>63</code>)存储符号位，指数位共11位(<code>52~62</code>)，尾数部分52位(<code>0~51</code>)。<br><img src="/img/blog/double.png" alt="image"></p><blockquote><p>虽然有了 IEEE 754 标准，但是各家在实现上还是有一些区别，尤其是舍入规则上。这导致了跨平台，尤其是跨 CPU 架构的情况下，执行同一个浮点数计算得到的结果可能不一样</p></blockquote><h3 id="2-二进制的科学计数法">2. 二进制的科学计数法</h3><p>十进制的科学计数法，数字可以写成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup></mrow></mrow><annotation encoding="application/x-tex">{a}\times{10^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">a</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>，例如 <code>2074390000</code>可以写成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.07439</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">{2.07439}\times10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2.07439</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</p><p>类似的，二进制也可以这样表示，例如，<code>1101.101</code>可以写成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.101101</mn><mo>×</mo><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">{1.101101}\times2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">1.101101</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>。</p><p>那么，带有小数的二进制，和十进制之间是怎么互相转换的呢？</p><p>二进制转十进制比较简单，例如，<code>1101.101</code>= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">{1}\times{2^3} + 1\times{2^2}+0\times{2^1}+1\times{2^0} +1\times{2^{-1}}+ 0\times{2^{-2}}+ 1\times{2^{-3}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">1</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span>=13.625</p><p>而十进制转二进制，要分为整数部分和小数部分，以上面的<code>13.625</code>为例，分为整数部分<code>13</code>和小数部位<code>0.625</code></p><p>整数部分，通过不停地除以2直到0，取余数来得到：</p><p><img src="/img/blog/double_dec_2_bin.png" alt="image"></p><p>小数部分，通过不停地乘以2直到0，取整数部分来得到：</p><p><img src="/img/blog/double_bin_2_dec.png" alt="image"></p><p>对于整数部分来说，不停地整除2，总是能到达0的，可以完整地转成二进制，但对于小数来说，不停地乘2减1，有可能永远也得不到0，这时候只能保存一定的精度了。</p><p><img src="/img/blog/double_bin_2_dec_2.png" alt="image"></p><blockquote><p>尾数保留精度时，并不是直接将第53位丢弃。IEEE 754 标准中定义了几种常见的舍入模式，但标准并没有具体规定编程语言或编译器必须采用哪种舍入模式作为默认行为，这也是导致不同平台或环境下的浮点数运算结果不一致的原因之一。</p></blockquote><h3 id="3-double在内存中的表示">3. <code>double</code>在内存中的表示</h3><p>根据 <code>IEEE</code>标准和二进制科学计数法，你可能觉得 <code>double</code>的 <code>0.3</code>，用二进制科学计数法写成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.00110011001</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">{1.00110011001}\times2^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">1.00110011001</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，那在内存中应该是这样的：<br><img src="/img/blog/double-w.png" alt="image"><br>但实际上是下面这样：<br><img src="/img/blog/double-r.png" alt="image"></p><ul><li>首先，这个指数位的-2，和整数在内存中的表示不同，并不使用最高位作为符号位，而是使用偏移算法：存储的数据=元数据+1023，所以-2在指数位中存储的是-2+1023=1021，即01111111101，11位二进制范围是0~2047，所以指数位范围是-1022~1023（0和2047被用作特殊值处理，见下面）</li><li>其次，有效数字的表示，由于二进制的科学计数法总是写成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mn>1.</mn><mi>x</mi></mrow><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">{1.x}\times2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">1.</span><span class="mord mathnormal">x</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>，第一位总是1，所以在内存中干脆不存储这一位，这样有效数字可以多表示一位。</li></ul><h3 id="4-非规约形式的浮点数">4. 非规约形式的浮点数</h3><p>除了规约浮点数，<code>IEEE754-1985</code>标准采用非规约浮点数，用来解决填补绝对意义下最小规格数与零的距离。<br>如果浮点数的指数部分的编码值是0，分数部分非零，那么这个浮点数将被称为非规约形式的浮点数。<br>这种情况下，尾数部分没有前导的1，即非规约浮点数的尾数小于1且大于0，此时表示的是非常接近0的小数。<br>除此之外，还有三种特殊值：</p><ul><li>如果指数是0并且尾数的小数部分是0，这个数是±0（和符号位相关）</li><li>如果指数是2047(全为1)并且尾数的小数部分是0，这个数是±无穷大（同样和符号位相关）</li><li>如果指数是2047(全为1)并且尾数的小数部分不是0，这个数是非数字（NaN）</li></ul><h3 id="5-double所能表示的精确的最大正整数">5. <code>double</code>所能表示的精确的最大正整数</h3><p>我们将尾数部分全都置1，再加上隐藏的1，可以形成一个53位的二进制数：<code>11111111111111111111111111111111111111111111111111111</code><br>再把指数部分设成<code>52+1023</code>，形成的数，就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>53</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{2}^{53}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord">2</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">53</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，这就是double所能表示的精确的最大正整数。</p><p>而如果再加1，会怎样呢？尾数部分为变成0，而指数加1，变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>53</mn></msup></mrow><annotation encoding="application/x-tex">{2}^{53}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span class="mord">2</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">53</span></span></span></span></span></span></span></span></span></span></span></span>，但这个数已经不精确了，我们用python来测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">9007199254740991.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a - <span class="hljs-number">1</span><br><span class="hljs-number">9007199254740990.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a + <span class="hljs-number">1</span><br><span class="hljs-number">9007199254740992.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a + <span class="hljs-number">2</span><br><span class="hljs-number">9007199254740992.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a + <span class="hljs-number">3</span><br><span class="hljs-number">9007199254740994.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a - <span class="hljs-number">1</span> == a<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a + <span class="hljs-number">1</span> == a + <span class="hljs-number">2</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>可以看到，这里无法区分出<code>9007199254740992</code>和<code>9007199254740993</code>这两个数，因为它们在内存中的表现是一样的，如下图所示，最后黑色的0和1是被丢弃的，而只保留了52位尾数之后，两个数字就变成一样的，无法精确区分这两个数字了。</p><p><img src="/img/blog/double_max_1.png" alt="image"></p><p>参考资料</p><ul><li><a href="https://zh.wikipedia.org/wiki/IEEE_754">维基百科 IEEE 754</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis的跳跃表</title>
    <link href="/skip_list_in_redis/"/>
    <url>/skip_list_in_redis/</url>
    
    <content type="html"><![CDATA[<p>在Redis中，有一种高效的数据结构叫做有序集合(<code>zset</code>)</p><p>它是一种集合，其中每个成员(<code>member</code>)都会关联一个分数(<code>score</code>)。<br><code>zset</code>既可以快速地通过<code>member</code>找到该成员对应的分数，又可以按照分数的大小进行范围查询，这对于实现排行榜等功能非常有用。那么<code>zset</code>是如何实现这样的功能的呢？答案是跳跃表（<code>skiplist</code>）。</p><h3 id="1-zset的底层实现">1. <code>zset</code>的底层实现</h3><p>思考这么几个问题：</p><ul><li><code>zset</code>是如何快速的根据成员取得对应的分数？</li><li><code>zset</code>是如何快速的取得指定排行区间的所有成员和分数？</li><li><code>zset</code>的<code>zrevrange</code>(逆序)又是如何实现的？</li><li><code>zset</code>如何计算一个成员的排位？</li><li>…<br>第一个问题我们很容易想到使用哈希表，实际上<code>zset</code>的底层实现，就是一个哈希表+跳跃表，看看结构：(对于元素数量少的情况，<code>zset</code>会使用另一种实现方式，我们这里不作讨论)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><p>哈希表(<code>dict</code>)大部分人都了解，那么对于这个跳跃表(<code>zskiplist</code>)，又是怎样的结构呢？</p><h3 id="2-跳跃表的结构和特性">2.跳跃表的结构和特性</h3><p>跳跃表是一种有序链表+多层索引的结构，使得包含n个元素的有序序列的查找和插入操作的平均时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mrow><mo fence="true">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omicron \left(\log{n}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathrm">O</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 。<br>跳跃表是按层建造的，最底层是一个普通的有序链表。<br>众所周知，如果是一个有序的数组，我们可以通过二分查找，很快的找到其中的某个元素。那么对于一个有序的链表，我们有没有办法也使用二分查找呢？<br>跳跃表的想法就是用空间换时间：在最底层的原始链表上面，加多一层索引，元素数量为原始链表的一半，如图所示：<br><img src="/img/blog/skiplist-level-2.png" alt="image"><br>这样查找的时候，原本要比较n个元素，通过使用索引，减少到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 。<br>但是这样还不够，所以我们在上面再多加几层索引，如图所示：<br><img src="/img/blog/skiplist-level-n.png" alt="image"><br>理论上，对于元素数量为n的链表，我们可以建立 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\log_{2}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span></span> 层索引。<br>这样，我们就能通过从最高层开始，通过二分查找的方式，快速的查找某个数值在链表中的位置。</p><h3 id="3-实现细节">3.实现细节</h3><p>Redis的跳跃表实现主要有两个结构：<code>zskiplistNode</code>和<code>zskiplist</code>，其中<code>zskiplistNode</code>是跳跃表的结点，而<code>zskiplist</code>则记录整个表的一些信息，如结点的数量等。<br><img src="/img/blog/skiplist.png" alt="image"><br>上图展示了一个跳跃表的实例。左边代表着跳跃表的整体结构：<code>zskiplist</code></p><p><code>zskiplist</code>的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplist</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *header, *tail;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p><code>header</code>和<code>tail</code>：分别指向跳跃表头结点和尾结点，其中头结点在<code>zskiplist</code>创建时生成，并不实际存储数据。<br><code>length</code>：跳跃表的长度，通过这个变量，可以在O(1)时间内获取长度。<br><code>level</code>：当前跳跃表中最高的层，不包括头结点。</p><blockquote><p>每次创建新结点的时候，<code>redis</code>根据<code>幂次定律</code>(越大的数出现概率越小)随机生成一个高度(介于1和32)，作为当前结点的<code>level</code>数组的长度，也就是这个结点的高度。</p></blockquote><p>结点<code>zskiplistNode</code>的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    sds ele;<br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p><code>ele</code>：每个结点的成员，<code>sds</code>是<code>redis</code>内置的简单动态字符串结构(<code>Simple Dynamic String</code>)<br><code>score</code>：每个结点的分数，是<code>double</code>类型<br><code>backward</code>：回退指针，用于从表尾向表头遍历。用来实现<code>zrevrange</code>。<br><code>level</code>：每个层级上的索引。</p><p>注意<code>level</code>中的每一层，除了指向下一个结点的指针以外，还有一个<code>span</code>表示跨度，即下一个结点和当前结点的距离。(示例图中，箭头上面的数字)<br>这个跨度用来计算排行，由于<code>redis</code>的跳跃表并不是严格的按照每层数量减半的实现，所以在高层，每一次跨越几个原始结点，只能存储在这个<code>span</code>中，而在遍历的时候，通过计算跨度的和，就可以知道当前排在第几位了。</p><blockquote><p>上图中红色和绿色都是<code>zskiplistNode</code>结构，其中<code>header</code>的<code>backward</code>/<code>ele</code>/<code>score</code>都是没用的，所以省略了没画出来</p></blockquote><h3 id="4-与其他结构的对比">4 与其他结构的对比</h3><p>和红黑树这类平衡树结构相比，跳跃表的算法复杂度一样，而主要优势在于实现简单，且在并发环境下更加高效；<br>与哈希表相比，跳跃表支持有序数据的快速检索和范围查询，但牺牲了一些插入和删除操作的性能。<br>总的来说，跳跃表是一种空间换时间，以及用随机化处理平衡的高效数据结构。</p><h3 id="参考资料：">参考资料：</h3><ul><li><a href="https://juejin.cn/post/6893072817206591496">深入理解Redis跳跃表的基本实现和特性</a></li><li><a href="https://en.wikipedia.org/wiki/Skip_list">维基百科：skip list</a></li><li><a href="https://marticles.github.io/2019/03/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-Zset%E5%8E%9F%E7%90%86/">深入理解Redis Zset原理</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>skynet之main服务的启动</title>
    <link href="/skynet_main_service_bootstrap/"/>
    <url>/skynet_main_service_bootstrap/</url>
    
    <content type="html"><![CDATA[<h3 id="1-skynet启动的第一个服务">1 skynet启动的第一个服务</h3><p>我们知道，<code>skynet</code>以<code>服务(service</code>)为基础，那么，当我们输入指令<code>&gt; skynet examples/config</code>之后，<code>skynet</code>启动的第一个服务会是什么呢？</p><p>这一点我们先看看最常用的配置文件，通常会有这么两行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">start = <span class="hljs-string">&quot;main&quot;</span><span class="hljs-comment">-- main script</span><br>bootstrap = <span class="hljs-string">&quot;snlua bootstrap&quot;</span><span class="hljs-comment">-- The service for bootstrap</span><br></code></pre></td></tr></table></figure><p>其中，<code>bootstrap</code>是指定启动的第一个服务：<code>snlua</code>，及其参数：<code>bootstrap</code></p><p><code>snlua</code>是<code>skynet</code>内置的一个最常用的<code>c服务</code>，以<code>.so</code>的形式存在于<code>cservice/</code>目录下，简单地说，就是用来启动一个lua服务。</p><p><code>snlua bootstrap</code>则是将<code>bootstrap</code>作为参数传给<code>snlua</code>服务。</p><p><code>snlua</code>的具体功能，可以看代码<code>service_snlua.c</code>，简单地说，就是加载一些库，修改一些函数(<code>coroutine.resume / coroutine.wrap</code>)，切换分代CG等等。然后就调用<code>./lualib/loader.lua</code>文件，将参数(<code>bootstrap</code>)传入。</p><blockquote><p>理论上，我们也可以配置成<code>bootstrap=&quot;snlua myBoot&quot;</code>，使用我们自己的启动脚本，但没必要，skynet默认的bootstrap已经帮我们将事情都处理好了。</p></blockquote><h3 id="2-lualib-loader-lua做了些什么">2 ./lualib/loader.lua做了些什么</h3><p><code>loader.lua</code>可以接收多个参数，其中第一个参数是服务名，其他的是服务启动的参数。</p><p><code>loader</code>如何根据服务名来找到对应的入口文件呢？</p><p>答案是配置文件中的<code>luaservice</code>，在示例的配置中，<code>luaservice</code>长这样：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">luaservice = root..<span class="hljs-string">&quot;service/?.lua;&quot;</span>..root..<span class="hljs-string">&quot;test/?.lua;&quot;</span>..root..<span class="hljs-string">&quot;examples/?.lua;&quot;</span>..root..<span class="hljs-string">&quot;test/?/init.lua&quot;</span><br></code></pre></td></tr></table></figure><p>那么，<code>skynet</code>会<strong>按顺序</strong>依次查找文件<code>service/bootstrap.lua</code>,<code>test/boostrape.lua</code>,<code>examples/bootstrap.lua</code>,<code>test/bootstrap/init.lua</code>，找到<strong>第一个</strong>存在的文件，然后调用这个文件。如果所有文件都不存在，则抛出错误。</p><blockquote><p>在调用<code>bootstrap.lua</code>之前，如果配置文件配置了<code>preload</code>，则会先调用这个<code>preload</code>文件</p></blockquote><blockquote><p>理论上，我们也可以配置自己的<code>loader</code>文件，不一定要使用系统的<code>loader.lua</code>，但这通常也是不必要的</p></blockquote><h3 id="3-bootstrap-lua又做了些什么">3. bootstrap.lua又做了些什么</h3><p>通过<code>loader.lua</code>，我们找到了<code>service/bootstrap.lua</code>这个文件，这里就是常用的<code>skynet</code>的<code>lua</code>服务写法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">--...</span><br>    skynet.<span class="hljs-built_in">exit</span>()<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>这里主要是启动了一些服务：</p><ul><li><code>launcher</code>：用来启动、管理<code>lua</code>服务，先启动这个服务，后续才能调用<code>skynet.newservice</code>等函数来启动服务。</li><li><code>cdummy</code>：启动<code>harbor</code>服务，基本没什么用</li><li><code>datacenterd</code>：数据中心，可以查询、存储一些<code>key/value</code></li><li><code>service_mgr</code>：管理单例服务，<code>skynet.uniqueservice</code>和<code>skynet.queryservice</code>时使用。</li></ul><p>启动完这些服务之后，就是启动<code>main</code>服务了，即配置文件中<code>start=&quot;main&quot;</code>这里指定的服务名，就是我们自己的服务的入口了~</p><p>当<code>bootstrap</code>做完所有事情之后，则调用<code>skynet.exit</code>，结束<code>bootstrap</code>服务。</p><blockquote><p>如果配置文件的<code>harbor</code>大于0，则还会启动<code>cmaster</code>和<code>cslave</code>服务。这是早期的设计，后续<code>skynet</code>已经不建议配置<code>harbor</code>了。</p></blockquote><blockquote><p>如果配置文件配置了<code>enablessl</code>，这里还会启动相关的服务</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>skynet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet</tag>
      
      <tag>lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Docker搭建Redis Cluster集群</title>
    <link href="/redis_cluster_use_docker/"/>
    <url>/redis_cluster_use_docker/</url>
    
    <content type="html"><![CDATA[<p>Cluster模式是Redis的一种高级集群模式，它通过数据分片和分布式存储实现了负载均衡和高可用性。在Cluster模式下，Redis将所有的键值对数据分散在多个节点上。每个节点负责一部分数据，称为 <code>槽位</code>。通过对数据的分片，Cluster模式可以突破单节点的内存限制，实现更大规模的数据存储。</p><p><img src="/img/blog/redis-cluster.png" alt="image"></p><p>Redis Cluster将数据分为 <code>16384</code>个槽位，每个节点负责管理一部分槽位。当客户端向Redis Cluster发送请求时，Cluster会根据 <code>键</code>的哈希值将请求路由到相应的节点。具体来说，Redis Cluster使用CRC16算法计算键的哈希值，然后对16384取模，得到槽位编号。</p><p>使用Cluster集群有以下优点：</p><ul><li>数据分片，实现大规模数据存储。</li><li>负载均衡，提高系统性能。</li><li>自动故障转移，提高可用性。</li></ul><h3 id="使用Docker搭建RedisCluster集群">使用Docker搭建RedisCluster集群</h3><p>使用Docker容器，可以很方便地搭建RedisCluster集群。</p><ol><li><p>首先，我们要创建虚拟网卡，主要是用于redis-cluster能于外界进行网络通信，一般常用桥接模式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create --subnet=192.168.100.0/24 redis_cluster_net<br></code></pre></td></tr></table></figure><p>Redis-cluster集群最小规模是三主三从，我们安排一下容器结点的IP和端口：</p></li></ol><table><thead><tr><th>IP</th><th>PORT</th><th>REMARK</th></tr></thead><tbody><tr><td>192.168.100.101</td><td>7001</td><td>主节点master-1</td></tr><tr><td>192.168.100.102</td><td>7002</td><td>主节点master-2</td></tr><tr><td>192.168.100.103</td><td>7003</td><td>主节点master-3</td></tr><tr><td>192.168.100.104</td><td>6379</td><td>从节点slave-1</td></tr><tr><td>192.168.100.105</td><td>6379</td><td>从节点slave-2</td></tr><tr><td>192.168.100.106</td><td>6379</td><td>从节点slave-3</td></tr></tbody></table><ol start="2"><li><p>接下来创建redis.conf配置文件。<br>我们先新建一个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir docker-redis-cluster &amp;&amp; cd docker-redis-cluster<br></code></pre></td></tr></table></figure><p>编辑 <code>master</code>结点配置文件 <code>redis-master-1.conf</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs redis">port 7001<br>cluster-enabled yes<br>cluster-config-file nodes.conf<br>cluster-node-timeout 5000<br>appendonly yes<br>daemonize no<br>protected-mode no<br>pidfile  /var/run/redis.pid<br>cluster-announce-ip 192.168.242.93<br></code></pre></td></tr></table></figure></li></ol><p>主结点配置说明：</p><ul><li>port: 指定了启动的端口号</li><li>cluster-enabled: yes启动允许集群</li><li>cluster-config-file: 集群配置文件(自动创建)</li><li>cluster-node-timeout: 集群超时时间(毫秒)</li><li>appendonly: 持久化 yes</li><li>daemonize: 后台运行 no</li><li>protected-mode: no 允许外部IP访问</li><li>cluster-announce-ip: 集群节点 IP，如果想要集群可以供外网访问，这里直接填宿主机的IP</li></ul><p>三个主结点，每个的配置只是port不同，可以使用shell指令复制多两份出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in &#123;2..3&#125;;  do sed &quot;s/port 7001/port 700$i/&quot; redis-master-1.conf &gt; redis-master-$i.conf ; done<br></code></pre></td></tr></table></figure><p><code>slave</code>结点配置文件 <code>redis-slave-1.conf</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs redis">port 6379<br>cluster-enabled no<br>appendonly yes<br>daemonize no<br>protected-mode no<br>pidfile  /var/run/redis.pid<br>slaveof 192.168.100.101 7001<br></code></pre></td></tr></table></figure><p>和配置主结点一样，使用shell指令复制多两份出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in &#123;2..3&#125;;  do sed &quot;s/\(192.168.100\).101 7001/\1.10$i 700$i/&quot; redis-slave-1.conf &gt; redis-slave-$i.conf ; done<br></code></pre></td></tr></table></figure><p><code>slave</code>结点配置说明：</p><ul><li>cluster-enabled: no 不参与集群分配</li><li>appendonly: 持久化 yes</li><li>daemonize: 后台运行 no</li><li>slaveof 192.168.100.101 7001: 直接指定成为对应master的从节点</li></ul><h3 id="创建docker-compose-yml">创建docker-compose.yml</h3><p>我们使用 <code>docker-compose.yml</code>来创建6个docker容器。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">version: <span class="hljs-string">&#x27;3.7&#x27;</span><br><br>x-image:<br>  &amp;default-image<br>    redis:<span class="hljs-number">5.0</span>.<span class="hljs-number">7</span><br><br>networks:<br>  redis_cluster_net:<br>    name: redis_cluster_net<br><br><br>services:<br>  redis-master-<span class="hljs-number">1</span>:<br>    image: *default-image<br>    container_name: redis-master-<span class="hljs-number">1</span><br>    command:<br>      [<span class="hljs-string">&quot;redis-server&quot;</span>, <span class="hljs-string">&quot;/home/redis/cluster/redis.conf&quot;</span>]<br>    networks:<br>      redis_cluster_net:<br>        ipv4_address: <span class="hljs-number">192.168</span>.<span class="hljs-number">100.101</span><br>    volumes:<br>      - ./redis-master-<span class="hljs-number">1</span>.conf:/home/redis/cluster/redis.conf<br>      - ./master-<span class="hljs-number">1</span>-data:/data<br>    ports:<br>      - <span class="hljs-number">7001</span>:<span class="hljs-number">7001</span><br>      - <span class="hljs-number">17001</span>:<span class="hljs-number">17001</span><br><br>  redis-master-<span class="hljs-number">2</span>:<br>    image: *default-image<br>    container_name: redis-master-<span class="hljs-number">2</span><br>    command:<br>      [ <span class="hljs-string">&quot;redis-server&quot;</span>, <span class="hljs-string">&quot;/home/redis/cluster/redis.conf&quot;</span> ]<br>    networks:<br>      redis_cluster_net:<br>        ipv4_address: <span class="hljs-number">192.168</span>.<span class="hljs-number">100.102</span><br>    volumes:<br>      - ./redis-master-<span class="hljs-number">2</span>.conf:/home/redis/cluster/redis.conf<br>      - ./master-<span class="hljs-number">2</span>-data:/data<br>    ports:<br>      - <span class="hljs-number">7002</span>:<span class="hljs-number">7002</span><br>      - <span class="hljs-number">17002</span>:<span class="hljs-number">17002</span><br><br>  redis-master-<span class="hljs-number">3</span>:<br>    image: *default-image<br>    container_name: redis-master-<span class="hljs-number">3</span><br>    command:<br>      [ <span class="hljs-string">&quot;redis-server&quot;</span>, <span class="hljs-string">&quot;/home/redis/cluster/redis.conf&quot;</span> ]<br>    networks:<br>      redis_cluster_net:<br>        ipv4_address: <span class="hljs-number">192.168</span>.<span class="hljs-number">100.103</span><br>    volumes:<br>      - ./redis-master-<span class="hljs-number">3</span>.conf:/home/redis/cluster/redis.conf<br>      - ./master-<span class="hljs-number">3</span>-data:/data<br>    ports:<br>      - <span class="hljs-number">7003</span>:<span class="hljs-number">7003</span><br>      - <span class="hljs-number">17003</span>:<span class="hljs-number">17003</span><br>  <br>  redis-slave-<span class="hljs-number">1</span>:<br>    image: *default-image<br>    container_name: redis-slave-<span class="hljs-number">1</span><br>    command:<br>      [ <span class="hljs-string">&quot;redis-server&quot;</span>, <span class="hljs-string">&quot;/home/redis/cluster/redis.conf&quot;</span> ]<br>    networks:<br>      redis_cluster_net:<br>        ipv4_address: <span class="hljs-number">192.168</span>.<span class="hljs-number">100.104</span><br>    volumes:<br>      - ./redis-slave-<span class="hljs-number">1</span>.conf:/home/redis/cluster/redis.conf<br>      - ./slave-<span class="hljs-number">1</span>-data:/data<br>    ports:<br>      - <span class="hljs-number">7004</span>:<span class="hljs-number">6379</span><br><br>  redis-slave-<span class="hljs-number">2</span>:<br>    image: *default-image<br>    container_name: redis-slave-<span class="hljs-number">2</span><br>    command:<br>      [ <span class="hljs-string">&quot;redis-server&quot;</span>, <span class="hljs-string">&quot;/home/redis/cluster/redis.conf&quot;</span> ]<br>    networks:<br>      redis_cluster_net:<br>        ipv4_address: <span class="hljs-number">192.168</span>.<span class="hljs-number">100.105</span><br>    volumes:<br>      - ./redis-slave-<span class="hljs-number">2</span>.conf:/home/redis/cluster/redis.conf<br>      - ./slave-<span class="hljs-number">2</span>-data:/data<br>    ports:<br>      - <span class="hljs-number">7005</span>:<span class="hljs-number">6379</span><br><br>  redis-slave-<span class="hljs-number">3</span>:<br>    image: *default-image<br>    container_name: redis-slave-<span class="hljs-number">3</span><br>    command:<br>      [ <span class="hljs-string">&quot;redis-server&quot;</span>, <span class="hljs-string">&quot;/home/redis/cluster/redis.conf&quot;</span> ]<br>    networks:<br>      redis_cluster_net:<br>        ipv4_address: <span class="hljs-number">192.168</span>.<span class="hljs-number">100.106</span><br>    volumes:<br>      - ./redis-slave-<span class="hljs-number">3</span>.conf:/home/redis/cluster/redis.conf<br>      - ./slave-<span class="hljs-number">3</span>-data:/data<br>    ports:<br>      - <span class="hljs-number">7006</span>:<span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>注意3个主结点的容器，需要同时映射7001端口和17001端口。每个Redis Cluster节点都需要打开两个TCP连接。用于服务客户端的普通Redis TCP端口(如6379)，以及数据端口加上10000得到的端口(例如16379)。第二个高端口用于集群总线，是使用二进制协议的节点到节点通信通道。节点使用集群总线进行故障检测、配置更新、故障转移授权等。</p><p>配置好 <code>docker-compose.yml</code>文件之后，使用命令启动容器：<br><code>docker-compose up -d</code></p><h3 id="创建集群并分配slots">创建集群并分配slots</h3><p>此时仅仅创建了三对主从节点，但是三个主节点(7001, 7002, 7003)是孤立的，并且还未分配slots。</p><p>进入任意一个主结点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it redis-master-1 /bin/bash<br></code></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster create 192.168.100.101:7001 192.168.100.102:7002 192.168.100.103:7003 --cluster-replicas 0<br></code></pre></td></tr></table></figure><p>在提示后输入 <code>yes</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="hljs-built_in">hash</span> slots allocation on 3 nodes...</span><br>Master[0] -&gt; Slots 0 - 5460<br>Master[1] -&gt; Slots 5461 - 10922<br>Master[2] -&gt; Slots 10923 - 16383<br>M: 6ef13d3f45b4598c90a072a47bd076d7fbc50969 192.168.100.101:7001<br>   slots:[0-5460] (5461 slots) master<br>M: 431173ccf97e48aa0c67a66ef25e3013d14ac4a8 192.168.100.102:7002<br>   slots:[5461-10922] (5462 slots) master<br>M: 5e1f46e8552d1e98b6b1b657c1d188b78b03e6fc 192.168.100.103:7003<br>   slots:[10923-16383] (5461 slots) master<br>Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes<br></code></pre></td></tr></table></figure><p>正常来说就会得到以下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="hljs-built_in">join</span> the cluster</span><br>Waiting for the cluster to join<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node 192.168.100.101:7001)</span><br>M: 6ef13d3f45b4598c90a072a47bd076d7fbc50969 192.168.100.101:7001<br>   slots:[0-5460] (5461 slots) master<br>M: 5e1f46e8552d1e98b6b1b657c1d188b78b03e6fc 192.168.242.93:7003<br>   slots:[10923-16383] (5461 slots) master<br>M: 431173ccf97e48aa0c67a66ef25e3013d14ac4a8 192.168.242.93:7002<br>   slots:[5461-10922] (5462 slots) master<br>[OK] All nodes agree about slots configuration.<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="hljs-keyword">for</span> open slots...</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span><br>[OK] All 16384 slots covered.<br></code></pre></td></tr></table></figure><p>这时候这个三主三从的redis集群就创建好了。</p><h3 id="测试连接">测试连接</h3><p>使用集群模式(<code>-c</code>)连接主结点：<br><code>&gt; redis-cli -h 192.168.100.101 -p 7001 -c</code><br>然后随便设置一个值:</p><p><code>192.168.100.101:7001&gt; set k1 v1</code></p><p>如果计算出来这个 <code>key</code>的 <code>slot</code>不在当前结点，则会提示：</p><p><code>-&gt; Redirected to slot [12706] located at 192.168.242.93:7003 OK</code></p><p>表示通过计算 <code>slot</code>分配到 <code>192.168.242.93:7003</code>结点去了。</p><p>我们通过普通模式连接到主结点 <code>192.168.242.93:7003</code>和从结点 <code>192.168.100.106:6379</code>，都能查到这个 <code>k1</code></p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://jasonkayzk.github.io/2020/01/17/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Redis%E9%9B%86%E7%BE%A4-%E4%B8%89%E4%B8%BB%E4%B8%89%E4%BB%8E/">使用Docker部署Redis集群-三主三从</a></li><li><a href="https://juejin.cn/post/6992872034065727525">Docker 搭建 Redis Cluster集群 每一步都带有操作图、命令！！！</a></li><li><a href="https://www.cnblogs.com/yidengjiagou/p/17345831.html">详解Redis三大集群模式，轻松实现高可用！</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在MySQL的PREPARE中绑定WHERE IN子句参数</title>
    <link href="/mysql_prepare_where_in/"/>
    <url>/mysql_prepare_where_in/</url>
    
    <content type="html"><![CDATA[<h3 id="在MySQL的PREPARE中绑定WHERE-IN子句参数">在MySQL的PREPARE中绑定WHERE IN子句参数</h3><h4 id="1-PREPARE简介">1. PREPARE简介</h4><p>在 MySQL 中，PREPARE 是一种用于准备执行动态 SQL 语句的机制。通过 PREPARE，你可以将一个 SQL 查询或操作的查询计划（执行计划）准备好，然后在稍后的时间点执行它，而不是立即执行。这带来了以下好处：</p><ol><li>SQL 注入防护： 使用 PREPARE 可以在准备 SQL 语句时进行参数绑定，从而防止 SQL 注入攻击。因为动态构建 SQL 查询字符串并将参数直接插入字符串是一种不安全的做法，而 PREPARE 允许你将参数作为占位符传递，从而提高了安全性。</li><li>性能优化： 通过预编译 SQL 语句，数据库管理系统可以在执行之前进行一些优化工作，如查询计划的生成和缓存。这可以提高查询的性能，特别是当同一条 SQL 语句需要多次执行时。</li><li>重用性： 通过准备语句，你可以在应用程序的生命周期内多次执行相同的 SQL 查询，而无需每次都重新构建查询字符串。这提高了代码的重用性和可维护性。</li><li>减少通信开销： 对于一些数据库连接，特别是远程连接，通信开销可能相对较高。通过准备语句，你可以在一次通信中将 SQL 查询计划发送到数据库服务器，然后多次执行该查询，减少了通信开销。</li></ol><!-- more --><h4 id="2-PREPARE使用">2. PREPARE使用</h4><p>下面是使用 PREPARE 和 EXECUTE 的一般步骤：</p><ol><li>使用 PREPARE 准备 SQL 语句，并将其分配给一个变量或标识符。</li><li>使用 EXECUTE 执行预编译的 SQL 语句，传递参数（如果有的话）。</li><li>可以多次使用 EXECUTE 执行相同的预编译语句，只需改变参数值。</li><li>使用 DEALLOCATE 或 CLOSE 来释放已经准备的语句，以释放资源。</li></ol><p>总的来说，PREPARE 的主要好处在于提高了安全性、性能和代码的可维护性。但是，它并不是在所有情况下都有益的，因此应谨慎使用，特别是对于只执行一次的查询。</p><h4 id="3-示例">3. 示例</h4><p>以下是一个使用<code>PREPARE</code>语句的示例，演示了如何查询一个名为<code>employees</code>的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 准备查询</span><br><span class="hljs-keyword">PREPARE</span> stmt <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;SELECT * FROM employees WHERE department = ?&#x27;</span>;<br><br><span class="hljs-comment">-- 绑定参数</span><br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@department</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Sales&#x27;</span>;<br><br><span class="hljs-comment">-- 执行查询</span><br><span class="hljs-keyword">EXECUTE</span> stmt <span class="hljs-keyword">USING</span> <span class="hljs-variable">@department</span>;<br><br><span class="hljs-comment">-- 关闭和清理</span><br><span class="hljs-keyword">DEALLOCATE</span> <span class="hljs-keyword">PREPARE</span> stmt;<br></code></pre></td></tr></table></figure><h4 id="4-使用PREPARE做IN查询">4. 使用PREPARE做IN查询</h4><p>当一条语句中，有<code>WHERE IN</code>这样的结构时，直接使用<code>PREPARE</code>并不会起到正确的结果，例如下面这条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">prepare</span> myFun <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;select * from user where id IN (?)&#x27;</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@str</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;1,2&#x27;</span>;<br><span class="hljs-keyword">execute</span> myFun <span class="hljs-keyword">using</span> <span class="hljs-variable">@str</span>;<br></code></pre></td></tr></table></figure><p>预期效果是查询出<code>id=1</code>和<code>id=2</code>两条数据，而实现上只能查出<code>id=1</code>的数据。</p><p>这时候我们可以用<code>FIND_IN_SET</code>函数来解决这个问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">prepare</span> myFun <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;select * from user where FIND_IN_SET(id, ?)&#x27;</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@str</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;1,2&#x27;</span>;<br><span class="hljs-keyword">execute</span> myFun <span class="hljs-keyword">using</span> <span class="hljs-variable">@str</span>;<br></code></pre></td></tr></table></figure><p>这样出来的结果就是<code>id=1</code>和<code>id=2</code>了。</p><p><code>FIND_IN_SET</code>是一个 MySQL 数据库函数，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">FIND_IN_SET(search_value, comma_separated_list)<br></code></pre></td></tr></table></figure><h4 id="参考资料">参考资料</h4><ul><li><a href="https://deepinout.com/mysql/mysql-questions/261_mysql_binding_parameters_for_where_in_clause_with_pdo.html">MySQL PDO绑定WHERE IN子句参数</a></li><li><a href="https://blog.csdn.net/Saintmm/article/details/125945979">MySQL如何对SQL做prepare预处理（解决IN查询SQL预处理仅能查询出一条记录的问题）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis Pipeline管道技术</title>
    <link href="/redis_pipeline/"/>
    <url>/redis_pipeline/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是pipeline">1.什么是pipeline</h3><p><code>Pipeline</code>是<code>Redis</code>提供的一种批量请求机制，可以在client端对多条命令进行打包，然后一次性发送给服务器，避免了多次网络往返的开销。</p><h3 id="2-pipeline的优势">2.pipeline的优势</h3><p>为了解释<code>pipeline</code>的作用，我们先思考一个问题:</p><p>如果客户端需要依次执行多条<code>Redis</code>命令，该如何处理？</p><!-- more --><ul><li>客户端一次执行一条命令，等待返回后再执行下一条。</li><li>客户端将多条命令一次性全部发出，然后再一次性读取所有返回。</li></ul><p>很明显第二种方式可以显著减少客户端与服务端的网络往返次数。</p><p>这也就是Pipeline带来的优势，可以在client端实现命令缓冲和打包，从而极大地减少客户端和服务端间的往返次数和等待时间。</p><p>###　3.pipeline工作原理<br>要理解<code>pipeline</code>的原理，我们首先需要了解Redis服务端处理命令的流程:</p><ol><li>客户端通过网络TCP连接发送命令到服务端</li><li>服务器解析命令，并从客户端读取全部参数</li><li>服务器执行命令逻辑并计算结果</li><li>服务器将响应发送会客户端</li></ol><p>在传统方式下，整个流程需要完成后客户端才能发送下一条命令。</p><p>而当使用<code>pipeline</code>时，变化主要在客户端:</p><ol><li>客户端不立即等待响应，而是继续发送后续请求命令</li><li>客户端会缓冲并一次性发送所有排队的命令</li><li>服务端仍按正常流程依次解析和响应这些命令</li><li>客户端最后一次性读取所有响应</li></ol><p>所以实际上服务端处理流程并无不同，改变主要是客户端如何打包和发送命令。服务端仍按正常方式依次执行。</p><p>这样就相当于消除了服务端处理每个命令间的客户端网络往返等待时间。</p><h3 id="4-pipeline实现方法">4.pipeline实现方法</h3><p>Redis提供了多种语言的客户端，均支持了<code>pipeline</code>功能，使用方法类似:</p><ol><li>启动一个<code>pipeline</code>批量操作环境</li><li>将需要发送的命令添加到<code>pipeline</code>队列中缓冲</li><li>最后触发批量执行，并读取所有的响应<br>例如在Python中:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> redis<br><br>conn = redis.Redis(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">6379</span>)<br>pipe = conn.pipeline()<br><br>pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br>pipe.get(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>pipe.incr(<span class="hljs-string">&#x27;counter&#x27;</span>)<br>pipe.hset(<span class="hljs-string">&#x27;hash&#x27;</span>, <span class="hljs-string">&#x27;k1&#x27;</span>, <span class="hljs-string">&#x27;v1&#x27;</span>)<br><br>result = pipe.execute()<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>其他语言的实现方式类似，底层均是向服务端发送缓冲的命令并按顺序读取回复。</p><h3 id="5-pipeline的注意事项">5.pipeline的注意事项</h3><p>使用<code>pipeline</code>时有一些需要注意的问题:</p><ol><li><code>pipeline</code>命令不保证原子性，中间命令可能会被其他客户端更改。</li><li><code>pipeline</code>本身不是一次<code>Redis</code>事务，每个命令可独立失败或成功。</li><li>非确定性命令如时间函数结果可能和预期不符。</li><li>网络问题可能导致<code>pipeline</code>完全失败，需要<code>retrying</code>逻辑。</li><li><code>pipeline</code>队列不要无限增长，需要设置合理长度。</li><li>避免在<code>pipeline</code>内部包含高延迟命令，可能会阻塞整个队列。</li></ol><p><code>pipeline</code>是一个非常强大的优化<code>Redis</code>网络访问的工具，但也需要注意上述问题，来确保其可靠和高效地运行。</p><h4 id="参考资料">参考资料</h4><ul><li><a href="https://redis.io/docs/manual/pipelining/">Redis pipelining</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL使用binlog恢复数据</title>
    <link href="/mysql_use_binlog/"/>
    <url>/mysql_use_binlog/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是Binlog">1. 什么是Binlog</h3><p>MySQL的二进制日志（Binlog）是一种事务日志，用于记录对数据库的更改操作。<br>Binlog主要用于MySQL复制和恢复:</p><ul><li>复制: 从库通过拉取主库的binlog实现主从数据一致</li><li>恢复: 通过重放binlog恢复数据丢失或误操作情况</li></ul><h4 id="1-1-Binlog的工作原理">1.1. Binlog的工作原理</h4><p>在MySQL中，每个事务都会在提交后生成相应的Binlog记录。<br>MySQL服务器会为每个客户端连接创建一个线程，称为Binlog Dump线程，<br>负责将Binlog的内容传送给从服务器，用于数据复制。<br>Binlog可以在服务器的文件系统中持久化存储，保证了数据的持久性。</p><!-- more --><h4 id="1-2-Binlog的格式">1.2. Binlog的格式</h4><p>MySQL支持多种Binlog格式，包括<code>Statement</code>(语句)、<code>Row</code>(行)和<code>Mixed</code>(混合)三种。不同格式在记录更改时的粒度和复制方式上有所不同：</p><ul><li><code>Statement</code>格式：记录SQL语句的执行内容，简单高效，但可能存在非确定性问题，如触发器的执行结果与主服务器不一致。</li><li><code>Row</code>格式：记录每一行数据的变更，提供了更精确的复制，但产生的日志量较大。</li><li><code>Mixed</code>格式：结合了<code>Statement</code>和<code>Row</code>格式的优点，MySQL根据具体的情况来选择合适的记录方式。</li></ul><h4 id="1-3-开启binlog">1.3 开启binlog</h4><p>要查看是否开启了binlog，可以通过以下方法:</p><ul><li>在MySQL中查询变量:<code>SHOW VARIABLES LIKE 'log_bin';</code></li><li>检查配置文件<code>my.cnf</code>中是否配置了<code>log-bin</code>参数</li><li>查看数据目录是否存在日志文件，默认名称类似<code>mysql-bin.000001</code></li></ul><p>如果未开启，可以配置<code>my.cnf</code>来开启binlog:</p><ul><li>在<code>my.cnf</code>配置文件中<code>[mysqld]</code>加入以下配置，然后重启MySQL:</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log-bin</span> = /var/lib/mysql/mysql-bin<br><span class="hljs-attr">binlog_format</span> = mixed <span class="hljs-comment"># 指定`statement` `row` `mixed`</span><br><span class="hljs-attr">server-id</span> = <span class="hljs-number">1</span>   <span class="hljs-comment"># 在集群中的唯一ID，如果只有一台服务器，可以随便配置</span><br></code></pre></td></tr></table></figure><h3 id="2-使用Binlog恢复数据">2. 使用Binlog恢复数据</h3><p>Binlog不仅用于数据复制，还可以用于数据恢复。当数据库发生误操作、数据损坏或数据丢失时，可以通过Binlog来还原数据。</p><h4 id="2-1-导出Binlog文件">2.1 导出Binlog文件</h4><p>在需要恢复数据的MySQL服务器上，首先需要导出Binlog文件。可以使用以下命令关闭当前的Binlog文件并生成一个新的Binlog文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> FLUSH LOGS;<br></code></pre></td></tr></table></figure><h4 id="2-2-使用mysqlbinlog工具">2.2 使用mysqlbinlog工具</h4><p>接下来，使用mysqlbinlog工具来解析Binlog文件，并将其中的SQL语句导出到一个文本文件中，可以使用以下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqlbinlog</span> binlog.<span class="hljs-number">000001</span> &gt; binlog.sql<br></code></pre></td></tr></table></figure><h4 id="2-3-恢复数据">2.3 恢复数据</h4><p>将导出的SQL语句文件binlog.sql导入到目标数据库中，即可还原数据：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u username -<span class="hljs-selector-tag">p</span> -h hostname dbname &lt; binlog<span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure><h3 id="3-高级数据恢复技巧">3. 高级数据恢复技巧</h3><p>除了基本的Binlog数据恢复外，还可以通过Binlog实现一些高级的数据恢复技巧：</p><h4 id="3-1-Point-in-Time-Recovery（PITR）">3.1 Point-in-Time Recovery（PITR）</h4><p>使用Binlog中的时间戳信息，可以实现在特定时间点之前恢复数据库数据，称为PITR恢复。通过在导出Binlog时指定时间戳参数，可以选择将数据库恢复到历史某个时间点的状态。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mysqlbinlog <span class="hljs-params">--start-datetime</span>  <span class="hljs-string">&quot;2023-07-30 17:00:00&quot;</span> mysql-bin.000001 &gt; <span class="hljs-string">/home/mysql_backup/binlog_raw.sql</span><br></code></pre></td></tr></table></figure><h4 id="3-2-数据库对象过滤">3.2 数据库对象过滤</h4><p>在解析Binlog时，可以使用mysqlbinlog工具提供的参数来选择只恢复某些数据库、表或者特定类型的SQL语句，从而实现更加精细化的数据恢复。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mysqlbinlog <span class="hljs-params">--database</span> sync_test mysql-bin.000001 &gt; <span class="hljs-string">/home/mysql_backup/binlog_raw.sql</span><br></code></pre></td></tr></table></figure><h4 id="4-总结">4 总结</h4><p>MySQL的Binlog是数据库的重要组成部分，它记录了数据库的更改操作，并为数据复制和数据恢复提供了有力支持。<br>通过了解Binlog的原理和使用技巧，我们可以更好地利用这一特性，保障数据库的稳健运行，并在必要时实现高级的数据恢复。然而，进行数据恢复时，请务必谨慎操作，以免造成不可逆的损失。</p><h4 id="参考资料">参考资料</h4><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/point-in-time-recovery-binlog.html">Point-in-Time Recovery Using Binary Log</a></li><li><a href="https://www.cnblogs.com/michael9/p/11923483.html">MySQL 5.7 - 通过 BINLOG 恢复数据</a></li><li><a href="https://www.jianshu.com/p/8e7e288c41b1">MySQL如何开启binlog？binlog三种模式的分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中使用JSON存储数据</title>
    <link href="/mysql_use_json/"/>
    <url>/mysql_use_json/</url>
    
    <content type="html"><![CDATA[<h3 id="1-概述：">1.概述：</h3><p>MySQL从5.7版本开始引入了对JSON数据类型的原生支持。<br>这个增强功能使开发人员能够直接在数据库中存储、操作和查询JSON数据。</p><p>MySQL的JSON字段为存储半结构化数据提供了更加灵活和高效的方式。<br>相比传统的关系型数据库，使用JSON字段的优势包括：</p><ul><li>灵活性：JSON字段可以存储不同结构的数据，无需提前定义表结构。</li><li>扩展性：可以轻松地添加新的属性或字段，无需修改表结构。</li><li>快速开发：适用于那些数据结构经常变化或者需要快速迭代开发的应用。<!-- MORE --></li></ul><h3 id="2-使用：">2.使用：</h3><p>要在MySQL中定义JSON字段，只需在创建表列时将数据类型指定为JSON即可。然后可以使用适当的语法将JSON数据插入到JSON字段中。以下是一个简单的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> my_table (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    data JSON<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_table <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 30&#125;&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;Jerry&quot;, &quot;age&quot;: 20&#125;&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，在插入JSON类型的字符串时，MySQL会对JSON字符串进行格式校验，如果格式有误，就无法插入。</p></blockquote><h3 id="3-查询：">3.查询：</h3><p>MySQL提供了强大的函数和运算符来查询JSON字段。可以使用<code>-&gt;</code>运算符从JSON字段中提取特定值，或使用<code>-&gt;&gt;</code>运算符将值提取为字符串。以下是一个示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> data<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.name&quot; <span class="hljs-keyword">AS</span> name, data<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.age&quot; <span class="hljs-keyword">AS</span> age<br><span class="hljs-keyword">FROM</span> my_table;<br></code></pre></td></tr></table></figure><p>查询结果：</p><table><thead><tr><th style="text-align:center">name</th><th style="text-align:center">age</th></tr></thead><tbody><tr><td style="text-align:center">“Tom”</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">“Jerry”</td><td style="text-align:center">20</td></tr></tbody></table><p>一样可以使用<code>where</code>语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> data<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.name&quot; <span class="hljs-keyword">AS</span> name, data<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.age&quot; <span class="hljs-keyword">AS</span> age <br><span class="hljs-keyword">FROM</span> my_table<br><span class="hljs-keyword">WHERE</span> data<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.age&quot; <span class="hljs-operator">&gt;</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure><p>查询结果：</p><table><thead><tr><th style="text-align:center">name</th><th style="text-align:center">age</th></tr></thead><tbody><tr><td style="text-align:center">“Tom”</td><td style="text-align:center">30</td></tr></tbody></table><h3 id="4-修改">4.修改</h3><ul><li>修改<code>data</code>中的<code>age</code>字段：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> my_table <br><span class="hljs-keyword">SET</span> `data` <span class="hljs-operator">=</span> JSON_SET(`data`, &quot;$.age&quot;, <span class="hljs-number">31</span>)<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ul><li>在<code>data</code>中添加<code>gender</code>字段：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> my_table <br><span class="hljs-keyword">SET</span> `data` <span class="hljs-operator">=</span> JSON_MERGE(`data`, <span class="hljs-string">&#x27;&#123;&quot;gender&quot;:&quot;male&quot;&#125;&#x27;</span>)<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="5-删除">5.删除</h3><ul><li>在<code>data</code>中删除<code>gender</code>字段：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> my_table<br><span class="hljs-keyword">SET</span> `data` <span class="hljs-operator">=</span> JSON_REMOVE(`data`, &quot;$.gender&quot;)<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="6-排序：">6.排序：</h3><p>MySQL中的JSON字段不支持直接排序。但是，我们可以使用带有<code>-&gt;&gt;</code>运算符的ORDER BY子句根据特定的JSON字段对结果集进行排序。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> my_table<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> data<span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span>&quot;$.age&quot;;<br></code></pre></td></tr></table></figure><p>查询结果：</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">data</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">{“age”: 20, “name”: “Jerry”}</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">{“age”: 30, “name”: “Tom”}</td></tr></tbody></table><h3 id="7-实现原理：">7.实现原理：</h3><p>在内部，MySQL使用一种优化的二进制格式（Binary JSON，简称BSON）来存储JSON数据。<br>这种格式可以高效地存储和检索JSON数据，提供高性能和较少的存储空间需求。</p><h4 id="参考资料：">参考资料：</h4><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/json.html">MySQL官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hiredis的同步模式和异步模式</title>
    <link href="/hiredis_sync_async/"/>
    <url>/hiredis_sync_async/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是hiredis">1.什么是hiredis</h3><p>Hiredis 是一个 C 语言编写的 Redis 客户端库，用于与 Redis 数据库进行交互。它提供了一个简洁而高效的接口，使开发人员可以方便地在自己的 C/C++ 项目中使用 Redis。<br>Hiredis 是一个开源项目，可从其官方 GitHub 仓库获取源代码，并在符合 BSD 许可证的条件下使用和分发。它被广泛应用于各种 C/C++ 项目中，特别是那些需要与 Redis 数据库进行快速、可靠和高性能交互的应用程序。</p><!-- more --><h3 id="2-安装hiredis">2.安装hiredis</h3><p>在<code>centos</code>中可以使用<code>yum</code>直接安装：<br><code>yum install hiredis-devel</code></p><p>或者直接从源码安装：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">git clone https://github.<span class="hljs-keyword">com</span>/redis/hiredis.git<br><span class="hljs-keyword">cd</span> hiredis/<br><span class="hljs-keyword">make</span><br><span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><h3 id="3-使用hiredis">3.使用hiredis</h3><p>使用同步的方式连接redis，只需要使用以下几个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">redisContext *<span class="hljs-title">redisConnect</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip, <span class="hljs-type">int</span> port)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">redisCommand</span><span class="hljs-params">(redisContext *c, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">freeReplyObject</span><span class="hljs-params">(<span class="hljs-type">void</span> *reply)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，发送指令的函数在使用上与<code>printf</code>类似，支持不定参数：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">reply</span> = redisCommand(context, <span class="hljs-string">&quot;SET foo bar&quot;</span>)<span class="hljs-comment">;</span><br><span class="hljs-attr">reply</span> = redisCommand(context, <span class="hljs-string">&quot;SET foo %s&quot;</span>, value)<span class="hljs-comment">;</span><br><span class="hljs-attr">reply</span> = redisCommand(context, <span class="hljs-string">&quot;SET key:%s %s&quot;</span>, myid, value)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>同时也支持二进制的参数：<br><code>reply = redisCommand(context, &quot;SET foo %b&quot;, value, (size_t) valuelen);</code><br>用<code>%b</code>表示二进制，然后传入二进制<code>value</code>及其长度<code>valuelen</code></p><p>可以封装成一个C++类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ hiredis.cpp -lhiredis</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hiredis/hiredis.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Redis</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Redis</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * host, <span class="hljs-type">int</span> port = <span class="hljs-number">6379</span>)&#123;<br>                c = <span class="hljs-built_in">redisConnect</span>(host, port);<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">NULL</span>)&#123;<br>                        cout &lt;&lt; <span class="hljs-string">&quot;cannot allocate redis context&quot;</span> &lt;&lt; endl;<br>                        <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (c-&gt;err)&#123;<br>                        cout &lt;&lt; c-&gt;errstr &lt;&lt; endl;<br>                        c = <span class="hljs-literal">NULL</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                &#125;<br>        &#125;<br><br>        ~<span class="hljs-built_in">Redis</span>()&#123;<br>                <span class="hljs-keyword">if</span> (c)&#123;<br>                        <span class="hljs-built_in">redisFree</span>(c);<br>                &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnect</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>                <span class="hljs-keyword">return</span> c != <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * key, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * value)</span></span><br><span class="hljs-function">        </span>&#123;<br>                redisReply *reply = (redisReply*) <span class="hljs-built_in">redisCommand</span>(c, <span class="hljs-string">&quot;set %s %s&quot;</span>, key, value);<br>                <span class="hljs-keyword">if</span> (reply == <span class="hljs-literal">NULL</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_STATUS)&#123;<br>                        cout &lt;&lt; reply-&gt;str &lt;&lt; endl;<br>                        success = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_ERROR) &#123;<br>                        cout &lt;&lt; reply-&gt;str &lt;&lt; endl;<br>                &#125;<br><br>                <span class="hljs-built_in">freeReplyObject</span>(reply);<br>                <span class="hljs-keyword">return</span> success;<br>        &#125;<br><br>        <span class="hljs-function">string <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* key)</span></span><br><span class="hljs-function">        </span>&#123;<br>                redisReply *reply = (redisReply*) <span class="hljs-built_in">redisCommand</span>(c, <span class="hljs-string">&quot;get %s&quot;</span>, key);<br>                string value;<br>                <span class="hljs-keyword">if</span> (reply == <span class="hljs-literal">NULL</span>)&#123;<br>                        <span class="hljs-keyword">return</span> value;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_STRING)&#123;<br>                        value = reply-&gt;str;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_ERROR)&#123;<br>                        cout &lt;&lt; reply-&gt;str &lt;&lt; endl;<br>                &#125;<br>                <span class="hljs-built_in">freeReplyObject</span>(reply);<br>                <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HSet</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * key, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * field, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * value)</span></span><br><span class="hljs-function">        </span>&#123;<br>                redisReply *reply = (redisReply*) <span class="hljs-built_in">redisCommand</span>(c, <span class="hljs-string">&quot;hset %s %s %s&quot;</span>, key, field, value);<br>                <span class="hljs-keyword">if</span> (reply == <span class="hljs-literal">NULL</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_STATUS)&#123;<br>                        cout &lt;&lt; reply-&gt;str &lt;&lt; endl;<br>                        success = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_ERROR) &#123;<br>                    cout &lt;&lt; reply-&gt;str &lt;&lt; endl;<br>                &#125;<br>                <span class="hljs-built_in">freeReplyObject</span>(reply);<br>                <span class="hljs-keyword">return</span> success;<br>        &#125;<br><br>        <span class="hljs-function">string <span class="hljs-title">HGet</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* key, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * field)</span></span><br><span class="hljs-function">        </span>&#123;<br>                redisReply *reply = (redisReply*) <span class="hljs-built_in">redisCommand</span>(c, <span class="hljs-string">&quot;hget %s %s&quot;</span>, key, field);<br>                string value;<br>                <span class="hljs-keyword">if</span> (reply == <span class="hljs-literal">NULL</span>)&#123;<br>                        <span class="hljs-keyword">return</span> value;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_STRING)&#123;<br>                        value = reply-&gt;str;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_ERROR)&#123;<br>                        cout &lt;&lt; reply-&gt;str &lt;&lt; endl;<br>                &#125;<br>                <span class="hljs-built_in">freeReplyObject</span>(reply);<br>                <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br><span class="hljs-keyword">private</span>:<br>        redisContext *c;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">Redis <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (!r.<span class="hljs-built_in">isConnect</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        r.<span class="hljs-built_in">Set</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>        string value = r.<span class="hljs-built_in">Get</span>(<span class="hljs-string">&quot;id&quot;</span>);<br>        cout &lt;&lt; value &lt;&lt; endl;<br><br>        r.<span class="hljs-built_in">HSet</span>(<span class="hljs-string">&quot;map&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>        cout &lt;&lt; r.<span class="hljs-built_in">HGet</span>(<span class="hljs-string">&quot;map&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>) &lt;&lt; endl;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-hiredis的异步模式">4.hiredis的异步模式</h3><p>使用<code>hiredis</code>的同步模式时，每一个请求都需要等待回应之后，才能进行下一个请求，时间消耗在IO等待上。为了提高效率，可以使用异步模式，同时发送多个请求，然后回调处理。</p><p>使用<code>hiredis</code>的异步模式，需要绑定一个事件适配器，常用的有<code>libevent</code> <code>libuv</code>等。<br>下面以<code>libevent</code>为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hiredis/async.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hiredis/adapters/libevent.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_base</span> *eventBase = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signalHandler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">short</span> events, <span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d, exiting...\n&quot;</span>, sig);<br><br>    <span class="hljs-comment">// 停止事件循环</span><br>    <span class="hljs-built_in">event_base_loopbreak</span>(eventBase);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commandCallback</span><span class="hljs-params">(redisAsyncContext* context, <span class="hljs-type">void</span>* reply, <span class="hljs-type">void</span>* data)</span> </span>&#123;<br>    redisReply* r = <span class="hljs-built_in">reinterpret_cast</span>&lt;redisReply*&gt;(reply);<br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Command error: &quot;</span> &lt;&lt; context-&gt;errstr &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r-&gt;type == REDIS_REPLY_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Command error: &quot;</span> &lt;&lt; r-&gt;str &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理命令返回的结果</span><br>    std::cout &lt;&lt; r-&gt;str &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 这里不需要释放 reply 对象，hiredis的异步机制会自动释放</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> redisAsyncContext* context, <span class="hljs-type">int</span> status)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (status == REDIS_OK) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Connected to Redis&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 如果有密码，可以在这里验证</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 在连接成功后发送指令</span><br>        redisAsyncContext* asyncContext = <span class="hljs-built_in">const_cast</span>&lt;redisAsyncContext*&gt;(context);<br>        <span class="hljs-built_in">redisAsyncCommand</span>(asyncContext, commandCallback, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;SET mykey Hello&quot;</span>);<br>        <span class="hljs-built_in">redisAsyncCommand</span>(asyncContext, commandCallback, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;GET mykey&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Connection error&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    eventBase = <span class="hljs-built_in">event_base_new</span>();<br>    redisAsyncContext* context = <span class="hljs-built_in">redisAsyncConnect</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br><br>    <span class="hljs-keyword">if</span> (context-&gt;err) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Connection error: &quot;</span> &lt;&lt; context-&gt;errstr &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">redisLibeventAttach</span>(context, eventBase);<br>    <span class="hljs-built_in">redisAsyncSetConnectCallback</span>(context, connectCallback);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span> * signalEvent = <span class="hljs-built_in">evsignal_new</span>(eventBase, SIGINT, signalHandler, <span class="hljs-literal">nullptr</span>);;<br>    <span class="hljs-built_in">evsignal_add</span>(signalEvent, <span class="hljs-literal">nullptr</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;开始事件循环...&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">event_base_dispatch</span>(eventBase);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;事件循环结束...&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-built_in">event_free</span>(signalEvent);<br>    <span class="hljs-built_in">event_base_free</span>(eventBase);<br>    <span class="hljs-built_in">redisAsyncDisconnect</span>(context);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参考资料">参考资料</h4><ul><li><a href="https://www.jianshu.com/p/361b6dd7261f">hiRedis基础教程</a></li><li><a href="https://blog.csdn.net/qq_38731735/article/details/122812717">hiredis异步操作模型</a></li><li><a href="https://github.com/redis/hiredis#readme">github hiredis readme</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序的实现</title>
    <link href="/insertion_sort/"/>
    <url>/insertion_sort/</url>
    
    <content type="html"><![CDATA[<h3 id="1-概述">1. 概述</h3><p>插入排序（Insertion Sort）是一种简单且直观的排序算法。它的基本思想是将未排序的元素逐个插入到已排序的部分中，最终得到一个完全有序的序列。</p><h3 id="2-基本原理">2. 基本原理</h3><p>插入排序的核心思想是从未排序的元素中取出一个元素，将其逐个与已排序的元素进行比较，并插入到正确的位置，以保证已排序的部分始终有序。</p><p>具体步骤如下：</p><ol><li>假设第一个元素已经是有序的序列，可以将其视为已排序部分。</li><li>从第二个元素开始，将其与已排序部分的元素逐个比较，找到合适的位置插入。</li><li>将待插入元素插入到正确的位置后，将已排序部分的元素向后移动一位，为下一个元素的插入做准备。<br>重复步骤2和步骤3，直到所有元素都插入到正确的位置，得到完全有序的序列。</li></ol><!-- more --><h3 id="3-C-实现">3. C++实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 插入排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;               <span class="hljs-comment">// 从1开始 </span><br>        <span class="hljs-type">int</span> a = nums[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;            <span class="hljs-comment">// 在已经有序的[0, i)区间寻找nums[i]的位置  </span><br><span class="hljs-keyword">if</span> (nums[j] &gt; a)&#123;<br>                    nums[j + <span class="hljs-number">1</span>] = nums[j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                   nums[j + <span class="hljs-number">1</span>] = a;<br>                &#125;<br>       &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 测试用例</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; test_case = &#123;<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,<br>    &#125;;<br><br>        <span class="hljs-comment">// 加一些随机数组</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(len)</span></span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)&#123;<br>                        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>);<br>                &#125;<br>                test_case.<span class="hljs-built_in">push_back</span>(nums);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> nums : test_case)&#123;<br>                <span class="hljs-built_in">insertionSort</span>(nums);<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; nums[i])&#123;<br>                                cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;all is ok&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-希尔插入排序">4.希尔插入排序</h3><p>希尔插入排序（Shell Insertion Sort），也称为缩小增量排序，是插入排序的一种改进版本。希尔排序通过将待排序的元素划分为多个子序列来提高插入排序的效率，然后逐步缩小增量，最终完成整个序列的排序。希尔排序的核心思想是通过插入排序对子序列进行排序，从而减少元素的移动次数，提高排序的速度。</p><p>下面是希尔插入排序的基本步骤：</p><ol><li>首先，选择一个增量（间隔）序列，通常为原序列长度的一半，并对序列进行分组。每个分组称为一个子序列。</li><li>对每个子序列进行插入排序，即将每个子序列中的元素按照插入排序的方式进行排序。</li><li>缩小增量，重复步骤2，直到增量为1。</li><li>最后，对整个序列进行一次插入排序，以确保序列的完全有序性。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellInsertionSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> key = arr[i];<br>            <span class="hljs-type">int</span> j = i;<br><br>            <span class="hljs-keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123;<br>                arr[j] = arr[j - gap];<br>                j -= gap;<br>            &#125;<br><br>            arr[j] = key;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>普通的插入排序是逐个将元素插入已排序的序列中，如果待插入的元素较小，就需要将已排序的元素逐个后移，以腾出空位插入新元素。这种逐个移动的操作会导致数据的大量移动，特别是当待排序的数据集合较大时，效率会明显降低。</p><p>而希尔插入排序通过引入间隔序列，先进行间隔为较大值的插入排序，使得数据可以跳跃式地移动，从而快速地将较小的元素移到合适的位置。然后逐渐缩小间隔，再进行插入排序，直到间隔为1时，即退化为普通的插入排序。通过这种分组和逐渐缩小间隔的方式，希尔插入排序减少了数据移动的次数，提高了排序的效率。</p><h3 id="5-总结">5.总结</h3><p>插入排序是一种简单但有效的排序算法，适用于小规模的数据集或者基本有序的数据集。它的实现思路直观明了，通过逐个比较和插入来构建有序序列。<br>虽然插入排序的时间复杂度为<em>O</em>(n<sup>2</sup>)，在大规模数据集上的性能可能不如其他高级排序算法，但在某些特定场景下，插入排序的性能表现仍然是可接受的。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>归并排序的实现</title>
    <link href="/merge_sort/"/>
    <url>/merge_sort/</url>
    
    <content type="html"><![CDATA[<h3 id="1-概述">1.概述</h3><p>归并排序由冯·诺伊曼在1945年首次提出，是一种典型的分治思想：将问题拆分，递归处理，然后合并。归并排序的基础思路是，当一个数组的前后两部分都是有序的话，那么可以在<em>O</em>(<em>n</em>)时间内合并，使整个数组有序。归并排序的算法复杂度，在最好、最坏和平均的情况下，都是O(nLogn)。</p><h3 id="2-算法">2.算法</h3><p>归并排序有两种思路：自顶向下和自底向上。</p><p>自顶向下就是先将数组作为整体，设数组长度为n，则先分成两个n/2的数组，递归调用归并排序，然后再合并。</p><p>按照这个思路，可以先写出以下递归代码：</p><!-- more --><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>        <span class="hljs-type">int</span> mid = (i + j) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(nums, i, mid);        <span class="hljs-comment">// 使[i, mid]有序</span><br>        <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, j);    <span class="hljs-comment">// 使(mid, j]有序</span><br>        <span class="hljs-built_in">merge</span>(nums, i, mid, j);         <span class="hljs-comment">// 将有序的两部分[i, mid], (mid, j]合并起来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>merge</code>的过程也很简单：</p><ol><li>分配一个临时数组，空间大小和待合并的数组相同：<code>j-i+1</code></li><li>当左右两部分数组都有值时，对比两个数组中最小的值，将该值存放到临时数组中</li><li>当一个子数组的数据全部存放到临时数组后，将另一个子数组的数据依次放到临时数组中</li><li>将临时数组的数据替换到原数组中</li></ol><p>在这个过程需要分配额外的空间，其大小和数组长度一致，所以归并排序的空间复杂度为O(n)</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;      <span class="hljs-comment">// 分配临时数组</span><br>    <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;       <span class="hljs-comment">// i,j是左右两个子数组的起点，将移动到各自的终点：mid和right</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;          <span class="hljs-comment">// 当两个子数组都有数据时，进行对比</span><br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j])&#123;            <span class="hljs-comment">// 将小的值存放到tmp中</span><br>            tmp[k++] = nums[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tmp[k++] = nums[j++];<br>        &#125;<br>    &#125;<br>                                            <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;                      <span class="hljs-comment">// 如果左边数组还有值，放到tmp中</span><br>        tmp[k++] = nums[i++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;                    <span class="hljs-comment">// 如果右边数组还有值，放到tmp中</span><br>        tmp[k++] = nums[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; k; p++) &#123;           <span class="hljs-comment">// 将tmp的值复制到原数组</span><br>        nums[left + p] = tmp[p];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序也可以采用自底向上的思路，即先将数组n分成一个个长度为1的子数组，然后两两合并；再分成长度为2的子数组，合并；直到分成长度为n/2的子数组，再进行合并，达到最终有序。</p><p>代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左右边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> width = <span class="hljs-number">1</span>; width &lt; len; width *= <span class="hljs-number">2</span>)&#123;           <span class="hljs-comment">// 分组的边长，依次是1,2,4,8,...</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - width; i += width * <span class="hljs-number">2</span>)&#123;   <span class="hljs-comment">// 每个小数组的长度为width, 每次合并两个数组，i代表第1个数组的起点 </span><br>            <span class="hljs-type">int</span> j = i + width * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;                      <span class="hljs-comment">// j是第二个数组的右边界</span><br>            <span class="hljs-keyword">if</span> (j &gt; len - <span class="hljs-number">1</span>)&#123;<br>                j = len - <span class="hljs-number">1</span>;                            <span class="hljs-comment">// 不能超过整个数组的边界</span><br>            &#125;<br>            <span class="hljs-type">int</span> mid = i + width - <span class="hljs-number">1</span>;                    <span class="hljs-comment">// mid是第一个数组的右边界</span><br>            <span class="hljs-built_in">merge</span>(nums, i, mid, j);                     <span class="hljs-comment">// 合并</span><br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-C-11代码">3.C++11代码</h3><ul><li>递归版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])&#123;<br>            tmp[k++] = nums[j++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tmp[k++] = nums[i++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>        tmp[k++] = nums[i++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(j &lt;= right)&#123;<br>        tmp[k++] = nums[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        nums[left + i] = tmp[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= j)&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = (i + j) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(nums, i, mid);     <span class="hljs-comment">// 对左边进行排序</span><br>    <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, j); <span class="hljs-comment">// 对右边进行排序</span><br><br>    <span class="hljs-built_in">merge</span>(nums, i, mid, j);     <span class="hljs-comment">// 现在[i, mid]和[mid+1, j]都是有序的，将这两部分合并</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 测试用例</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; test_case = &#123;<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,<br>    &#125;;<br><br>    <span class="hljs-comment">// 加一些随机数组</span><br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(len)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)&#123;<br>            nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>);<br>        &#125;<br>        test_case.<span class="hljs-built_in">push_back</span>(nums);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> nums : test_case)&#123;<br>        <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; nums[i])&#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;all is ok&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>非递归版本</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(len)</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> width = <span class="hljs-number">1</span>; width &lt; len; width *= <span class="hljs-number">2</span>)&#123;                         <span class="hljs-comment">// witdh是每个小数组的大小，1，2，4，8, ...</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; len - width; left += <span class="hljs-number">2</span> * width)&#123;       <span class="hljs-comment">// left是每一对子数组的起点</span><br>            <span class="hljs-comment">// 处理每一对子数组，此时每个子数组的左右两边都是有序的</span><br>            <span class="hljs-type">int</span> mid = left + width - <span class="hljs-number">1</span>;          <span class="hljs-comment">//左数组的边界(因为left &lt; len - width，所以mid不会大于len - 1)</span><br>            <span class="hljs-type">int</span> right = left + width * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;   <span class="hljs-comment">//右数组的边界(不能超过len-1)</span><br>            <span class="hljs-keyword">if</span> (right &gt; len - <span class="hljs-number">1</span>)&#123;<br>                right = len - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 开始合并过程，此时[left, mid],(mid,right]都是有序的</span><br>            <span class="hljs-type">int</span> k = left;<br>            <span class="hljs-type">int</span> i = left;<br>            <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])&#123;<br>                    tmp[k++] = nums[j++];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    tmp[k++] = nums[i++];<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>                tmp[k++] = nums[i++];<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(j &lt;= right)&#123;<br>                tmp[k++] = nums[j++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            nums[i] = tmp[i];<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 测试用例</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; test_case = &#123;<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,<br>    &#125;;<br><br>        <span class="hljs-comment">// 加一些随机数组</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(len)</span></span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)&#123;<br>                        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>);<br>                &#125;<br>                test_case.<span class="hljs-built_in">push_back</span>(nums);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> nums : test_case)&#123;<br>                <span class="hljs-built_in">mergeSort</span>(nums);<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; nums[i])&#123;<br>                                cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;all is ok&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-复杂度分析">4.复杂度分析</h3><p>归并排序其实可以看作是二叉树的后序遍历，树的深度是log<sub>2</sub>n，每一层的merge，其比较的总次数都是数组长度n，因此总体的时间复杂度是<em>O</em>(<em>n</em>log<em>n</em>)。</p><h3 id="5-对比">5.对比</h3><p>归并排序和快速排序都是常见的基于比较的排序算法，它们的时间复杂度都为 <em>O</em>(<em>n</em>log<em>n</em>) 。<br>归并排序的最好、最坏和平均时间复杂度都为<em>O</em>(<em>n</em>log<em>n</em>)，并且它具有稳定性。<br>归并排序的主要缺点是需要开辟额外的空间，这可能在处理大规模数据时限制了其使用。</p><p>快速排序的优势在于它是一种原址排序算法，不需要额外的空间开销，它的平均速度比归并排序更快，特别是对于大规模数据集。但是，快速排序在最坏情况下的运行时间仍然不理想，而且它不具有稳定性，可能会改变相同元素的原始相对位置。<br>因此，选择归并排序或快速排序取决于具体问题和数据特征。在排序需要保持稳定性的问题上，归并排序是最好的选择；在其他问题上，特别是处理大规模数据时，快速排序通常更为高效。</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://en.wikipedia.org/wiki/Merge_sort">wikipedia</a></li><li><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/gui-bing-p-1387f/">归并排序详解及应用</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速排序的实现</title>
    <link href="/qsort/"/>
    <url>/qsort/</url>
    
    <content type="html"><![CDATA[<h3 id="1-概述">1.概述</h3><p>快速排序最初由一位英国计算机科学家<code>Tony Hoare</code>提出的。<code>Tony Hoare</code>是计算机科学领域的前辈之一，也是算法设计方面的专家，他在1960年代提出了快速排序算法，从那时起，快速排序就成为了许多经典排序算法之一，并且一直广泛应用在计算机科学领域。</p><p>快速排序被认为是最快的排序算法之一，因为它具有优秀的平均时间复杂度<em>O</em>(<em>n</em> log<em>n</em>)，此外，快速排序使用了一种高效的分治策略，可以在排序过程中大大降低内存占用，这使得它可以处理大型数据集，从而在实践中诞生出一个有效率的排序算法，因此被命名为<code>快速排序</code>。</p><h3 id="2-算法">2.算法</h3><p>快速排序算法的主要思想是分而治之，通过将数组分成较大和较小的两个子数组，然后再递归处理两个子数组，从而达到最终有序。</p><p>快速排序算法主要有以下几个步骤：</p><ol><li>挑选：从数组中取一个数作为基准值；可以是首尾或者中间数值，也可以是随机取一个;</li><li>分割：重新排列数组，使得比基准值小的数字都在基准值前面，比基准值大的数字都在基准值后面；</li><li>递归：将小于基准值的子数组和大于基准值的子数组按同样的方法排序；</li></ol><p>递归的结束条件，是数组的长度小于等于1。</p><p>根据以上描述，可以写出以下递归代码：</p><!--more--><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">void quickSort(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>) &#123;<br>    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>        <span class="hljs-built_in">int</span> pivotIndex = partition(nums, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>);  // 找出基准并进行分隔，返回基准值的下标<br>        quickSort(nums, <span class="hljs-built_in">left</span>, pivotIndex - <span class="hljs-number">1</span>);          // 此时<span class="hljs-built_in">left</span>到pivotIndex - <span class="hljs-number">1</span>的值都比基准值小，对这个子数组进行排序<br>        quickSort(nums, pivotIndex + <span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>);         // 此时pivotIndex - <span class="hljs-number">1</span>到<span class="hljs-built_in">right</span>的值都比基准值大，对这个子数组进行排序<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码的重点在于，如何实现<code>partition</code>？</p><ul><li>首先我们选择一个基准，放在最左边；</li><li>使用两个指针，一个从左往右寻找第一个大于等于基准的值，  另一个从右往左寻找第一个小于等于基准的值，  找到后交换两个值，逐渐实现目标：小于基准的在左，大于基准的在右。</li><li>最终，当左边指针超过右边指针时，就可以退出循环。  此时，右边指针指向小于基准的最后一个值的下标，将其与起始位置交换，并返回这个下标。<br><img src="/img/blog/qsort.gif" alt="图1 一次partition的过程"></li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = left; <br>    <span class="hljs-type">int</span> pivot = nums[p];                        <span class="hljs-comment">// 这里简单的将left当作基准</span><br>    <span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>, j = right;                <span class="hljs-comment">// [i, j]表示需要遍历的区间</span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;                            <span class="hljs-comment">// i &gt; j才结束，相等时也要和基准作比较</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt; pivot) ++i;  <span class="hljs-comment">// i停留在第一个大于等于基准的下标，或者找不到这样的数值，停留在j+1</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt; pivot) --j;  <span class="hljs-comment">// j停留在第一个小于等于基准的下标，或者找不到这样的数值，停留在i-1</span><br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;                        <span class="hljs-comment">// i &lt; j时，交换i和j的值，然后i++，j--，[i, j]依旧表示需要遍历的区间</span><br>            <span class="hljs-built_in">swap</span>(nums[i++], nums[j--]);     <span class="hljs-comment">// 此时[left, i)都是小于等于基准的值，(j, right]都是大于等于基准的值 </span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j)&#123;                  <span class="hljs-comment">// i == j 只有一种情况，那就是nums[i] == pivot，此时让i+1退出循环</span><br>            i++;<br>        &#125;       <br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums[p], nums[j]);             <span class="hljs-comment">// 此时j == i - 1，[left, i) == [left, j]，即j是小于等于pivot的最后一个下标，将其与基准交换，</span><br>    <span class="hljs-keyword">return</span> j;                           <span class="hljs-comment">// j就是基准最终的位置</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-C-11实现">3.C++11实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 分区函数，返回分区点下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = left; <br>    <span class="hljs-type">int</span> pivot = nums[p];                        <span class="hljs-comment">// 这里简单的将left当作基准</span><br>    <span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>, j = right;                <span class="hljs-comment">// [i, j]表示需要遍历的区间</span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;                            <span class="hljs-comment">// i &gt; j才结束，相等时也要和基准作比较</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt; pivot) ++i;  <span class="hljs-comment">// i停留在第一个大于等于基准的下标，或者找不到这样的数值，停留在j+1</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt; pivot) --j;  <span class="hljs-comment">// j停留在第一个小于等于基准的下标，或者找不到这样的数值，停留在i-1</span><br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;                        <span class="hljs-comment">// i &lt; j时，交换i和j的值，然后i++，j--，[i, j]依旧表示需要遍历的区间</span><br>            <span class="hljs-built_in">swap</span>(nums[i++], nums[j--]);     <span class="hljs-comment">// 此时[left, i)都是小于等于基准的值，(j, right]都是大于等于基准的值 </span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j)&#123;                  <span class="hljs-comment">// i == j 只有一种情况，那就是nums[i] == pivot，此时让i+1退出循环</span><br>            i++;<br>        &#125;       <br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums[p], nums[j]);             <span class="hljs-comment">// 此时j == i - 1，[left, i) == [left, j]，即j是小于等于pivot的最后一个下标，将其与基准交换，</span><br>    <span class="hljs-keyword">return</span> j;                           <span class="hljs-comment">// j就是基准最终的位置</span><br>&#125;<br><br><span class="hljs-comment">// 快速排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> pivotIndex = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-built_in">quickSort</span>(nums, left, pivotIndex - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(nums, pivotIndex + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 测试用例</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; test_case = &#123;<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,<br>    &#125;;<br><br>        <span class="hljs-comment">// 加一些随机数组</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(len)</span></span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)&#123;<br>                        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>);<br>                &#125;<br>                test_case.<span class="hljs-built_in">push_back</span>(nums);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> nums : test_case)&#123;<br>                <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; nums[i])&#123;<br>                                cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;all is ok&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-时间复杂度分析">4.时间复杂度分析</h3><p>快速排序每次<code>partition</code>的过程，都需要遍历一次数组，复杂度为<em>O</em>(<em>n</em>)。</p><p>最好的情况下，每次分区都能分成大小相同的两个子数组，需要log<sub>2</sub>n次递归。总体复杂度为<em>O</em>(<em>n</em> log<em>n</em>)</p><p>而在最坏的情况下，每次分区都有一个子数组为空，即所有数据都大于或都小于基准值，此时需要n次递归。总体复杂度为O(n<sup>2</sup>)</p><p>在平均情况下，快速排序的时间复杂度也是<em>O</em>(<em>n</em> log<em>n</em>)，这个可以用数学归纳法来证明。具体证明过程可以参考维基百科。</p><h3 id="5-局限">5.局限</h3><p>快速排序在大多数情况下都是最快的排序算法之一，但并不是完美的。</p><p>对于某些非常特殊的输入，快速排序可能会变得非常慢，因为它的时间复杂度在最坏情况下是O(n<sup>2</sup>)。</p><p>因此，有时候人们会使用其他排序算法，比如归并排序或堆排序，来替代快速排序，以确保排序的时间复杂度始终稳定在<em>O</em>(<em>n</em> log<em>n</em>)。</p><p>此外，还有一些特定于某些场景的排序算法，如桶排序、计数排序、基数排序等可以在特定的情况下更快，但其适用范围有限。</p><p>因此，具体取决于输入数据的特点和排序场景，选择合适的排序算法很重要。</p><h3 id="6-优化">6.优化</h3><ol><li>选择基准的时候，可以采用<code>三数取中法</code>：从最左、最右、和中间三个位置，取三个数中间的值作为基准，尽量使数组分割均匀；</li><li>当待排序的数组分割到一定大小的时候，使用插入排序。这是因为对于很小和部分有序的数组，快排不如插排好。</li><li>在一次分割结束后，可以把与基准相等的元素聚在一起，继续下次分割时，不用再对基准相等的元素进行分割。</li></ol><h4 id="参考">参考</h4><ul><li>[1] <a href="https://en.wikipedia.org/wiki/Quicksort">Wikipedia</a></li><li>[2] <a href="https://blog.csdn.net/insistGoGo/article/details/7785038">三种快速排序以及快速排序的优化</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL5.7忘记root密码如何重置</title>
    <link href="/mysql_5_7_reset_password/"/>
    <url>/mysql_5_7_reset_password/</url>
    
    <content type="html"><![CDATA[<ol><li><p>修改配置文件并重启:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@localhost ~]# vi /etc/my.cnf<br></code></pre></td></tr></table></figure><p>在[mysqld]添加一行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">skip</span><span class="hljs-operator">-</span><span class="hljs-keyword">grant</span><span class="hljs-operator">-</span>tables<br></code></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@localhost ~]# systemctl restart mysqld<br></code></pre></td></tr></table></figure></li><li><p>进入mysql修改root密码：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">[root@localhost ~]# mysql -uroot<br>mysql&gt; <span class="hljs-keyword">update</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string=<span class="hljs-keyword">password</span>(<span class="hljs-string">&#x27;newPassWord!123&#x27;</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">&#x27;root&#x27;</span> <span class="hljs-keyword">and</span> host=<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure><!-- more --><p>* mysql5.7密码要求<code>大小写字母</code>、<code>数字</code>和<code>特殊符号</code></p></li><li><p>退出mysql，重新修改<code>/etc/my.cnf</code>，删掉<code>skip-grant-tables</code></p></li><li><p>重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@localhost ~]# systemctl restart mysqld<br></code></pre></td></tr></table></figure></li><li><p>使用新密码登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@localhost ~]# mysql -uroot -p<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP正则表达式简介</title>
    <link href="/regular_expression/"/>
    <url>/regular_expression/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是正则表达式">1. 什么是正则表达式</h3><p><strong>正则表达式</strong>（regular expression）是一组用来匹配模式的字符串，通过定义规则，来实现字符串的<strong>查找、替换和验证</strong>。举个例子，你可以用正则表达式来查找一段字符串中的数字；再比如说，可以将字符串中符合规则的子串替换成另外的字符；又或者，用正则表达式来验证用户输入的密码是否符合某种规范（比如长度6-8个字符，同时包含大小写字母和数字）。</p><p>不同语言的正则表达式有不同的语法，不过大体上都有<strong>普通字符、限定符、元字符、转义符号、修饰符</strong>等概念，下面简单讲解一下PHP中的正则表达式。</p><!-- more --><h3 id="2-PHP的正则表达式">2.PHP的正则表达式</h3><p>我们先看看一个简单的模式，<code>/https?/i</code>，其中，<code>/</code>表示分隔符，两个<code>/</code>中间的部分就是匹配的规则。最后面的<code>i</code>是修饰符，在这里表示<strong>不匹分大小写</strong>，修饰符不是必需的。<code>https</code>属于普通符号，<code>\d</code>属于元字符，代表着<strong>数字0-9</strong></p><h6 id="2-1-分隔符">2.1 分隔符</h6><p>常用的分隔符是正斜线(/)，但除了字母、数字、空格、以及反斜线(\)外，其他符号都可以用作分隔符。比如：</p><p><code>/http:\/\//</code><br><code>#http:\\#</code></p><p>都是合法的PHP模式。可以看到，在模式中使用到分隔符的时候，必须用转义字符进行转义。所以如果分隔符经常在正则模式内出现，可以使用其他分隔符以便提高可读性。</p><h6 id="2-2-元字符">2.2 元字符</h6><p>正则表达式的强大源于它可以在模式中拥有选择和重复的能力。一些字符被赋予特殊的涵义，这些字符就是<strong>元字符</strong>。PHP中的元字符有以下这些：</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>用于转义</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置(或在多行模式下是行首)</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置(或在多行模式下是行尾)</td></tr><tr><td>.</td><td>匹配除换行符外的任何字符(默认)</td></tr><tr><td>[</td><td>开始字符类定义</td></tr><tr><td>]</td><td>结束字符类定义</td></tr><tr><td>|</td><td>开始一个可选分支</td></tr><tr><td>(</td><td>子组的开始标记</td></tr><tr><td>)</td><td>子组的结束标记</td></tr><tr><td>?</td><td>作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。</td></tr><tr><td>*</td><td>量词，0 次或多次匹配</td></tr><tr><td>+</td><td>量词，1 次或多次匹配</td></tr><tr><td>{</td><td>自定义量词开始标记</td></tr><tr><td>}</td><td>自定义量词结束标记</td></tr></tbody></table><p>在模式中，方括号<code>[]</code>内的部分称为<strong>字符类</strong>,表示一些字符的合集。在这一部分，有另外的元字符定义：</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>|转义字符</td><td></td></tr><tr><td>^</td><td>仅在作为第一个字符(方括号内)时，表明字符类取反</td></tr><tr><td>-</td><td>标记字符范围</td></tr></tbody></table><p>举个例子，<code>/[a-z0-9,]/</code>表示所有小写字母和数字和逗号，<code>[^a-z,]</code>表示除了小写字母和逗号之外的所有字符。</p><h6 id="2-3-转义序列（反斜线）">2.3 转义序列（反斜线）</h6><p>反斜线<code>\</code>通常的作用是转义，即表明取消该字符所代表的特殊涵义。比如上面提到的元字符<code>*</code>，如果要匹配到星号<code>*</code>，而不是表示0或多次匹配，则可以写成<code>\*</code>，反斜线在这里就起到转义作用。<br>　　<code>\</code>的第二个作用，是用来表示非打印字符，比如换行符<code>\n</code>，制表符<code>\t</code>等等。<br>　　对于<code>\</code>的另一个重要的作用，则是用来描述特定的字符类：</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>任意十进制数字</td></tr><tr><td>\D</td><td>任意非十进制数字</td></tr><tr><td>\w</td><td>任意单词字符(字母、数字、下划线)</td></tr><tr><td>\W</td><td>任意非单词字符</td></tr><tr><td>\s</td><td>任意空白字符</td></tr><tr><td>\S</td><td>任意非空白字符</td></tr></tbody></table><h6 id="2-4-量词">2.4 量词</h6><p>量词用于表示重复多次匹配，格式为<code>&#123;数字1,数字2&#125;</code>，其中两个数值都必须小于 65536， 并且第一个数字必须小于等于第二个。如果数字2被省略<code>&#123;数字1,&#125;</code>，则表示没有大限。如果连逗号都被省略<code>&#123;数字1&#125;</code>，则表示确定次数的匹配。<br>　　举例说明，<code>/a&#123;3,8&#125;/</code>表示匹配连续的3-8个a，<code>/a&#123;3,&#125;/</code>表示匹配大于等于3个a，<code>/a&#123;3&#125;/</code>表示匹配刚好3个a。常用的<code>*</code>,<code>+</code>,<code>?</code>分别等价于<code>&#123;0,&#125;</code>,<code>&#123;1,&#125;</code>,<code>&#123;0,1&#125;</code></p><p>默认情况下，量词都是“贪婪”的，也就是说， 它们会在不导致模式匹配失败的前提下，尽可能多的匹配字符。然而，如果一个量词紧跟着一个 ?(问号) 标记，它就会成为懒惰(非贪婪)模式， 它不再尽可能多的匹配，而是尽可能少的匹配。<br>　　例如，<code>/&lt;(.*)&gt;/</code>去匹配<code>&lt;head&gt;&lt;/head&gt;</code>会匹配到整个字符串，<code>.*</code>捕获出来的是<code>head&gt;&lt;/head</code>，而<code>/&lt;(.*?)&gt;/</code>去匹配<code>&lt;head&gt;&lt;/head&gt;</code>只会匹配到前面的<code>&lt;head&gt;</code>，<code>.*?</code>捕获到的是<code>head</code>。</p><h6 id="2-5-修饰符">2.5 修饰符</h6><p>在分隔符后面，可以加修饰符，常用的修饰符有：</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>不区分大小写</td></tr><tr><td>s</td><td>模式中的圆点符号<code>.</code>匹配所有的字符，包括换行符</td></tr><tr><td>m</td><td>匹配多行，使<code>^</code>、<code>$</code>分别匹配到每一行的行首和行尾</td></tr></tbody></table><p>例如<code>/abc/i</code>可以匹配到<code>abc</code>，<code>Abc</code>，<code>ABC</code>等字符串。</p><h6 id="2-6-子组和可选路径以及后向引用">2.6 子组和可选路径以及后向引用</h6><p>圆括号<code>()</code>中的部分即为子组，可以用来捕获其中的内容，也可以在其中加上<code>|</code>形成可选路径。比如<code>/cat(abc)+/</code>中<code>abc</code>为一个整体，可以匹配到<code>catabc</code>，<code>catabcabc</code>等。如果没有括号的话，<code>/catabc+/</code>就只能匹配到<code>catabccc</code>之类的字符串。再比如，<code>/cat(abc|def)/</code>中，<code>|</code>将子组分成两个可选的部分，能匹配到<code>catabc</code>，<code>catdef</code>两个字符串。值得注意的是，<code>|</code>可以为空的字符串，比如<code>/cat(abc|def|)/</code>可以匹配到<code>catabc</code>，<code>catdef</code>，<code>cat</code>三个字符串。<br>　　圆括号<code>()</code>中匹配到的内容，可以在后面通过<code>反斜杠+数字</code>的方式进行引用，这称之为后向引用。举例说明，<code>/(\d&#123;2&#125;)=\1/</code>可以匹配到<code>13=13</code>，<code>/(\d&#123;2&#125;)(\d&#123;2&#125;)=\2\1/</code>可以匹配到<code>1234=3412</code>，这里面<code>\1</code>，<code>\2</code>表示前面捕获到的第1、第2个子组。<br>　　如果想要在括号里只表示分组，而不需要捕获，可以在左括号后面紧跟字符串 <code>?:</code>，例如<code>/(?:\d&#123;2&#125;)(\d&#123;2&#125;)=\1/</code>中只会捕获到后面括号的一组内容，所以后面只能跟<code>\1</code>，可以匹配到<code>1234=34</code>这样的字符串。</p><h3 id="3-PHP的正则表达式的函数">3. PHP的正则表达式的函数</h3><h6 id="3-1-preg-match">3.1 preg_match</h6><p><code>preg_match</code>用于执行匹配正则表达式。其函数原型为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-variable">$pattern</span>,<span class="hljs-variable">$subject</span> [, &amp;<span class="hljs-variable">$matches</span> [, <span class="hljs-variable">$flags</span> = <span class="hljs-number">0</span> [, <span class="hljs-variable">$offset</span> = <span class="hljs-number">0</span> ]]])<br></code></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>pattern : 要搜索的模式，字符串类型。</li><li>subject : 输入字符串。</li><li>matches : 可选参数，会被填充为搜索结果。其中<code>matches[0]</code>将包含完整模式匹配到的文本， <code>matches[1]</code> 将包含第一个捕获子组匹配到的文本，以此类推。</li><li>flags : 可选参数，$flags 可以被设置为 PREG_OFFSET_CAPTURE，如果传递了这个标记，对于每一个出现的匹配，返回时都会附加上字符串偏移量（相对于目标字符串的）；</li><li>offset : 可选参数，用于指定从目标字符串的某个位置开始搜索(单位是字节)。</li></ul><p><code>preg_match</code>函数返回匹配次数，它的值将是0次（不匹配）或 1 次，因为<code>preg_match</code>在第一次匹配后将会停止搜索。</p><p>【示例】使用 preg_match() 函数搜索一个字符串。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/([a-z])(\d&#123;6&#125;)/&#x27;</span>, <span class="hljs-string">&quot;a123456,b654321&quot;</span>,<span class="hljs-variable">$output</span>);<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$output</span>);<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-number">1</span>Array<br>(<br>    [<span class="hljs-number">0</span>] =&gt; a123456<br>    [<span class="hljs-number">1</span>] =&gt; a<br>    [<span class="hljs-number">2</span>] =&gt; <span class="hljs-number">123456</span><br>)<br></code></pre></td></tr></table></figure><p>可以看到<code>preg_match</code>在匹配到一次后就结束了。如果想匹配到所有的话，可以使用<code>preg_match_all</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">preg_match_all</span>(<span class="hljs-string">&#x27;/([a-z])(\d&#123;6&#125;)/&#x27;</span>, <span class="hljs-string">&quot;a123456,b654321&quot;</span>,<span class="hljs-variable">$output</span>);<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$output</span>);<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-number">2</span>Array<br>(<br>    [<span class="hljs-number">0</span>] =&gt; <span class="hljs-title function_ invoke__">Array</span><br>        (<br>            [<span class="hljs-number">0</span>] =&gt; a123456<br>            [<span class="hljs-number">1</span>] =&gt; b654321<br>        )<br><br>    [<span class="hljs-number">1</span>] =&gt; <span class="hljs-title function_ invoke__">Array</span><br>        (<br>            [<span class="hljs-number">0</span>] =&gt; a<br>            [<span class="hljs-number">1</span>] =&gt; b<br>        )<br><br>    [<span class="hljs-number">2</span>] =&gt; <span class="hljs-title function_ invoke__">Array</span><br>        (<br>            [<span class="hljs-number">0</span>] =&gt; <span class="hljs-number">123456</span><br>            [<span class="hljs-number">1</span>] =&gt; <span class="hljs-number">654321</span><br>        )<br>)<br></code></pre></td></tr></table></figure><h6 id="3-2-preg-replace">3.2 preg_replace</h6><p><code>preg_replace</code>用于执行一个正则表达式的搜索和替换。其函数原型为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$replacement</span>, <span class="hljs-variable">$subject</span> [, <span class="hljs-variable">$limit</span> = -<span class="hljs-number">1</span> [, &amp;<span class="hljs-variable">$count</span>]])<br></code></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>pattern : 要搜索的模式。可以使一个字符串或字符串数组。</li><li>replacement : 用于替换的字符串或字符串数组。如果这个参数是一个字符串，并且 pattern 是一个数组，那么所有的模式都使用这个字符串进行替换。如果 pattern 和 replacement 都是数组，每个 pattern 使用 replacement 中对应的元素进行替换。如果 replacement 中的元素比 pattern 中的少，多出来的 pattern 使用空字符串进行替换。</li><li>subject : 要进行搜索和替换的字符串或字符串数组。</li><li>limit : 可选参数，每个模式在每个 subject 上进行替换的最大次数。默认是 -1(无限)。</li><li>count : 可选参数，如果指定，将会被填充为完成的替换次数。</li></ul><p>如果 subject 是一个数组，preg_replace() 返回一个数组，其他情况下返回一个字符串。</p><p>如果匹配被查找到，替换后的 subject 被返回，其他情况下返回没有改变的 subject。如果发生错误，返回 null 。</p><p>【示例】</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//把数字替换成*号</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&quot;/\d/&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>,<span class="hljs-string">&quot;abc123&quot;</span>); <span class="hljs-comment">//输出 abc***</span><br><span class="hljs-comment">//把[]替换成&#123;&#125;</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">preg_replace</span>([<span class="hljs-string">&quot;/\[/&quot;</span>,<span class="hljs-string">&quot;/\]/&quot;</span>],[<span class="hljs-string">&quot;&#123;&quot;</span>,<span class="hljs-string">&quot;&#125;&quot;</span>],<span class="hljs-string">&quot;[abc]&quot;</span>); <span class="hljs-comment">//输出 &#123;abc&#125;</span><br><span class="hljs-comment">//把=两边互换</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&quot;/(.*)=(.*)/&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-subst">$2</span>=<span class="hljs-subst">$1</span>&quot;</span>, <span class="hljs-string">&quot;key=val&quot;</span>); <span class="hljs-comment">//输出 val=key</span><br></code></pre></td></tr></table></figure><hr><p><strong><strong>【写在最后】</strong></strong><br>正则表达式虽好，但也不必要凡事尽皆正则。如果你仅仅想要检查某个字符串是否包含另外一个字符串，不要使用<code>preg_match</code>，使用<code>strpos</code>会更快。若凡是看到字符串就想正则，就会像这么一个段子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">我遇到了一个问题，我觉得可以用正则表达式来解决。好了，我现在有两个问题了。<br></code></pre></td></tr></table></figure><h4 id="参考">参考</h4><ul><li>[1] <a href="https://en.wikipedia.org/wiki/Regular_expression">Wikipedia</a></li><li>[2] <a href="https://www.runoob.com/regexp/regexp-tutorial.html">runoob正则表达式教程</a></li><li>[3] <a href="https://www.php.net/manual/zh/regexp.introduction.php">php官方文档-PCRE正则语法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
